import OVN_Northbound as nb
import OVN_Southbound as sb
import ovsdb
import allocate
import ovn
import lswitch
import lrouter
import multicast
import helpers
import ipam

/* Meter_Band table */
for (mb in nb.Meter_Band) {
    sb.Out_Meter_Band(.uuid_name = uuid2name(mb._uuid),
                      .action = mb.action,
                      .rate = mb.rate,
                      .burst_size = mb.burst_size)
}

/* Meter table */
for (meter in nb.Meter) {
    sb.Out_Meter(.name = meter.name,
                 .unit = meter.unit,
                 .bands = set_map_uuid2name(meter.bands))
}

/* Datapath_Binding table */
sb.Out_Datapath_Binding(uuid2name(uuid), 0, external_ids) :-
    nb.Logical_Switch(._uuid = uuid, .name = name, .external_ids = ids),
    var uuid_str = uuid2str(uuid),
    var external_ids = {
        var eids: Map<string, string> = map_empty();
        map_insert(eids, "logical-switch", uuid_str);
        map_insert(eids, "name", name);
        match (map_get(ids, "neutron:network_name")) {
            None -> (),
            Some{nnn} -> map_insert(eids, "name2", nnn)
        };
        eids
    }.

sb.Out_Datapath_Binding(uuid2name(uuid), 0, external_ids) :-
    nb.Logical_Router(._uuid = uuid, .name = name, .external_ids = ids, .enabled = enabled),
    is_enabled(enabled),
    var uuid_str = uuid2str(uuid),
    var external_ids = {
        var eids: Map<string, string> = map_empty();
        map_insert(eids, "logical-router", uuid_str);
        map_insert(eids, "name", name);
        match (map_get(ids, "neutron:router_name")) {
            None -> (),
            Some{nnn} -> map_insert(eids, "name2", nnn)
        };
        eids
    }.

sb.OutProxy_Datapath_Binding(uuid_name, tunkey, external_ids) :-
    sb.Out_Datapath_Binding(uuid_name, _, external_ids),
    TunKeyAllocation(uuid_name, tunkey).



/* Port_Binding table

relation Out_Port_Binding (
    uuid_name: string,
    logical_port: string,
    __type: string,
    gateway_chassis: Set<string>,
    ha_chassis_group: Set<string>,
    options: Map<string,string>,
    datapath: string,
    tunnel_key: integer,
    parent_port: Set<string>,
    tag: Set<integer>,
    virtual_parent: Set<string>.
    chassis: Set<uuid>,
    mac: Set<string>,
    nat_addresses: Set<string>,
    external_ids: Map<string,string>
)
*/

/* Case 1: Create a Port_Binding per logical switch port that is not of type "router" */
sb.Out_Port_Binding(.uuid_name          = uuid2name(lsp._uuid),
                    .logical_port       = lsp.name,
                    .__type             = lsp.__type,
                    .gateway_chassis    = set_empty(),
                    .ha_chassis_group   = set_empty(),
                    .virtual_parent     = set_empty(),
                    .options            = lsp.options,
                    .datapath           = uuid2name(sw.ls._uuid),
                    .tunnel_key         = 0,
                    .parent_port        = lsp.parent_name,
                    .tag                = tag,
                    .mac                = lsp.addresses,
                    .nat_addresses      = set_empty(),
                    .external_ids       = eids) :-
    &SwitchPort(.lsp = lsp, .sw = &sw),
    SwitchPortNewDynamicTag(lsp._uuid, opt_tag),
    var tag: Set<integer> = match (opt_tag) {
        None -> lsp.tag,
        Some{t} -> set_singleton(t)
    },
    lsp.__type != "router",
    var eids = {
        var eids = lsp.external_ids;
        match (map_get(lsp.external_ids, "neutron:port_name")) {
            None -> (),
            Some{name} -> map_insert(eids, "name", name)
        };
        eids
    }.


/* Case 2: Create a Port_Binding per logical switch port of type "router" */
sb.Out_Port_Binding(.uuid_name          = uuid_name,
                    .logical_port       = lsp.name,
                    .__type             = __type,
                    .gateway_chassis    = set_empty(),
                    .ha_chassis_group   = set_empty(),
                    .virtual_parent     = set_empty(),
                    .options            = options,
                    .datapath           = uuid2name(sw.ls._uuid),
                    .tunnel_key         = 0,
                    .parent_port        = lsp.parent_name,
                    .tag                = set_empty(),
                    .mac                = lsp.addresses,
                    .nat_addresses      = nat_addresses,
                    .external_ids       = eids) :-
    &SwitchPort(.lsp = lsp,
                .sw = &sw,
                .peer = Some{&rport@RouterPort{.router = &Router{.lr=lr, .l3dgw_port = l3dgw_port}}}),
    var uuid_name = uuid2name(lsp._uuid),
    var eids = {
        var eids = lsp.external_ids;
        match (map_get(lsp.external_ids, "neutron:port_name")) {
            None -> (),
            Some{name} -> map_insert(eids, "name", name)
        };
        eids
    },
    Some{var router_port} = map_get(lsp.options, "router-port"),
    var opt_chassis = map_get(lr.options, "chassis"),
    (var __type, var options) = {
        var options: Map<string, string> = map_singleton("peer", router_port);
        match (opt_chassis) {
            None -> {
                ("patch", options)
            },
            Some{chassis} -> {
                map_insert(options, "l3gateway-chassis", chassis);
                ("l3gateway", options)
            }
        }
    },
    var nat_addresses: Set<string> = {
        match (map_get(lsp.options, "nat-addresses")) {
            None -> { set_empty() },
            Some{"router"} -> {
                if (is_some(l3dgw_port) or is_some(opt_chassis)) {
                    get_nat_addresses(rport)
                } else { set_empty() }
            },
            Some{nat_addresses} -> {
                /* Only accept manual specification of ethernet address
                 * followed by IPv4 addresses on type "l3gateway" ports. */
                if (is_some(opt_chassis)) {
                    match (extract_lsp_addresses(nat_addresses)) {
                        None -> {
                            warn("Error extracting nat-addresses.");
                            set_empty()
                        },
                        Some{_} -> { set_singleton(nat_addresses) }
                    }
                } else { set_empty() }
            }
        }
    }.

/* Case 3: Port_Binding per logical router port */
sb.Out_Port_Binding(.uuid_name          = uuid_name,
                    .logical_port       = lrp.name,
                    .__type             = __type,
                    .gateway_chassis    = set_empty(),
                    .ha_chassis_group   = set_empty(),
                    .virtual_parent     = set_empty(),
                    .options            = map_union(map_union(options1, options2), extra_options),
                    .datapath           = uuid2name(router.lr._uuid),
                    .tunnel_key         = 0,
                    .parent_port        = set_empty(),
                    .tag                = set_empty(), // always empty for router ports
                    .mac                = set_singleton("${lrp.mac} ${set_space_sep(lrp.networks)}"),
                    .nat_addresses      = set_empty(),
                    .external_ids       = lrp.external_ids) :-
    &RouterPort(.lrp = lrp, .router = &router, .peer = peer),
    RouterPortRAOptionsComplete(lrp._uuid, extra_options),
    var uuid_name = uuid2name(lrp._uuid),
    (var __type, var options1) = match (map_get(router.lr.options, "chassis")) {
        /* TODO: derived ports */
        None -> ("patch", map_empty(): Map<string, string>),
        Some{lrchassis} -> ("l3gateway", map_singleton("l3gateway-chassis", lrchassis))
    },
    var options2 = match (router_peer_name(peer)) {
        None -> map_empty(): Map<string, string>,
        Some{peer_name} -> map_singleton("peer", peer_name)
    },
    var eids = {
        var eids = lrp.external_ids;
        match (map_get(lrp.external_ids, "neutron:port_name")) {
            None -> (),
            Some{name} -> map_insert(eids, "name", name)
        };
        eids
    }.

function get_router_load_balancer_ips(router: Router): Set<string> =
{
    var all_ips: Set<string> = set_empty();
    for (lb in router.lbs) {
        for (vip in deref(lb).vips) {
            (var vip_key, _) = vip;
            /* node->key contains IP:port or just IP. */
            match (ip_address_and_port_from_lb_key(vip_key)) {
                None -> (),
                Some{(ip_address, _, _)} -> set_insert(all_ips, ip_address)
            }
        }
    };
    all_ips
}

/* Returns an array of strings, each consisting of a MAC address followed
 * by one or more IP addresses, and if the port is a distributed gateway
 * port, followed by 'is_chassis_resident("LPORT_NAME")', where the
 * LPORT_NAME is the name of the L3 redirect port or the name of the
 * logical_port specified in a NAT rule.  These strings include the
 * external IP addresses of all NAT rules defined on that router, and all
 * of the IP addresses used in load balancer VIPs defined on that router.
 */
function get_nat_addresses(rport: RouterPort): Set<string> =
{
    var addresses: Set<string> = set_empty();
    var router = deref(rport.router);
    var has_redirect = is_some(router.l3dgw_port);
    match (eth_addr_from_string(rport.lrp.mac)) {
        None -> addresses,
        Some{mac} -> {
            var c_addresses = "${mac}";
            var central_ip_address = false;

            /* Get NAT IP addresses. */
            for (natref in router.nats) {
                var nat = deref(natref);
                match (ip_parse_masked(nat.external_ip)) {
                    Left{_} -> (),
                    Right{(ip, mask)} -> {
                        if (mask == oVS_BE32_MAX()) {
                            /* Determine whether this NAT rule satisfies the conditions for
                             * distributed NAT processing. */
                            if (has_redirect and nat.__type == "dnat_and_snat" and
                                (not set_is_empty(nat.logical_port)) and (not set_is_empty(nat.external_mac))) {
                                /* Distributed NAT rule. */
                                match (eth_addr_from_string(set_space_sep(nat.external_mac))) {
                                    Some{emac} -> {
                                        set_insert(addresses,
                                                   "${emac} ${nat.external_ip} is_chassis_resident(\"${set_space_sep(nat.logical_port)}\")")
                                    },
                                    None -> ()
                                }
                            } else {
                                /* Centralized NAT rule, either on gateway router or distributed
                                 * router. */
                                c_addresses = c_addresses ++ " ${nat.external_ip}";
                                central_ip_address = true
                            }
                        } else ()
                    }
                }
            };

            /* A set to hold all load-balancer vips. */
            var all_ips: Set<string> = get_router_load_balancer_ips(router);

            for (ip_address in all_ips) {
                c_addresses = c_addresses ++ " ${ip_address}";
                central_ip_address = true
            };

            if (central_ip_address) {
                /* Gratuitous ARP for centralized NAT rules on distributed gateway
                 * ports should be restricted to the gateway chassis. */
                if (has_redirect) {
                    c_addresses = c_addresses ++ " is_chassis_resident(${router.redirect_port_name})"
                } else ();

                set_insert(addresses, c_addresses)
            } else ();
            addresses
        }
    }
}

/* Extra options computed for router ports by the logical flow generation code */
relation RouterPortRAOptions(lrp: uuid, options: Map<string, string>)

relation RouterPortRAOptionsComplete(lrp: uuid, options: Map<string, string>)

RouterPortRAOptionsComplete(lrp, options) :-
    RouterPortRAOptions(lrp, options).
RouterPortRAOptionsComplete(lrp, map_empty()) :-
    nb.Logical_Router_Port(._uuid = lrp),
    not RouterPortRAOptions(lrp, _).


function ha_chassis_group_uuid_name(lr_uuid: uuid): string = { "hacg" ++ uuid2name(lr_uuid) }
function ha_chassis_uuid_name(chassis_uuid: uuid): string = { "hac" ++ uuid2name(chassis_uuid) }

/*
 * Create derived port for Logical_Router_Ports with non-empty 'gateway_chassis' column.
 */

/* Create derived ports */
sb.Out_Port_Binding(.uuid_name          = "cr" ++ uuid2name(lrp._uuid),
                    .logical_port       = chassis_redirect_name(lrp.name),
                    .__type             = "chassisredirect",
                    .gateway_chassis    = set_empty(),
                    .ha_chassis_group   = ha_chassis_group,
                    .virtual_parent     = set_empty(),
                    .options            = map_singleton("distributed-port", lrp.name),
                    .datapath           = uuid2name(lr_uuid),
                    .tunnel_key         = 0,
                    .parent_port        = set_empty(),
                    .tag                = set_empty(),  //always empty for router ports
                    .mac                = set_singleton("${lrp.mac} ${set_space_sep(lrp.networks)}"),
                    .nat_addresses      = set_empty(),
                    .external_ids       = lrp.external_ids) :-
    DistributedGatewayPort(lrp, lr_uuid),
    var ha_chassis_group_uuid_name = ha_chassis_group_uuid_name(lr_uuid),
    var ha_chassis_group = set_singleton(ha_chassis_group_uuid_name).

/* Referenced chassis.
 *
 * These tables track the sb.Chassis that a packet that traverses logical
 * router 'lr_uuid' can end up at (or start from).  This is used for
 * sb.Out_HA_Chassis_Group's ref_chassis column. */
relation RefChassis(lr_uuid: uuid, chassis_uuid: uuid)
RefChassis(lr_uuid, chassis_uuid) :-
    ReachableLogicalRouter(lr_uuid, lr2_uuid),
    FirstHopLogicalRouter(lr2_uuid, ls_uuid),
    LogicalSwitchPort(lsp_uuid, ls_uuid),
    nb.Logical_Switch_Port(._uuid = lsp_uuid, .name = lsp_name),
    sb.Port_Binding(.logical_port = lsp_name, .chassis = chassis_uuids),
    var chassis_uuid = FlatMap(chassis_uuids).
relation RefChassisSet(lr_uuid: uuid, chassis_uuids: Set<uuid>)
RefChassisSet(lr_uuid, chassis_uuids) :-
    RefChassis(lr_uuid, chassis_uuid),
    var chassis_uuids = Aggregate((lr_uuid), group2set(chassis_uuid)).

/* HA_Chassis_Group and HA_Chassis. */
sb.Out_HA_Chassis_Group(uuid_name, name, ha_chassis, ref_chassis,
                        external_ids) :-
    HAChassis(lr_uuid, chassis_name, priority, external_ids),
    chassis_rec in sb.Chassis(.name = chassis_name),
    var ha_chassis_uuid_name = ha_chassis_uuid_name(chassis_rec._uuid),
    var ha_chassis = Aggregate((lr_uuid), group2set(ha_chassis_uuid_name)),
    var uuid_name = ha_chassis_group_uuid_name(lr_uuid),
    HAChassisGroup(lr_uuid, name, external_ids),
    RefChassisSet(lr_uuid, ref_chassis).

sb.Out_HA_Chassis(ha_chassis_uuid_name, chassis, priority, external_ids) :-
    HAChassis(lr_uuid, chassis_name, priority, external_ids),
    chassis_rec in sb.Chassis(.name = chassis_name),
    var ha_chassis_uuid_name = ha_chassis_uuid_name(chassis_rec._uuid),
    DistributedGatewayPort(dgp_lrp, lr_uuid),
    var chassis = set_singleton(chassis_rec._uuid).

/* Add allocated qdisc_queue_id and tunnel key to Port_Binding.
 */
sb.OutProxy_Port_Binding(.uuid_name          = pbinding.uuid_name,
                         .logical_port       = pbinding.logical_port,
                         .__type             = pbinding.__type,
                         .gateway_chassis    = pbinding.gateway_chassis,
                         .ha_chassis_group   = set_empty(),
                         .virtual_parent     = set_empty(),
                         .options            = options,
                         .datapath           = pbinding.datapath,
                         .tunnel_key         = tunkey,
                         .parent_port        = pbinding.parent_port,
                         .tag                = pbinding.tag,
                         .mac                = pbinding.mac,
                         .nat_addresses      = pbinding.nat_addresses,
                         .external_ids       = pbinding.external_ids) :-
    sb.Swizzled_Port_Binding[pbinding],
    PortTunKeyAllocation(pbinding.uuid_name, tunkey),
    QueueIDAllocation(pbinding.uuid_name, qid),
    var options = match (qid) {
        None -> pbinding.options,
        Some{id} -> map_insert_imm(pbinding.options, "qdisc_queue_id", "${id}")
    }.

/*
 * SB_Global: copy nb_cfg and options from NB.
 * If NB_Global does not exist yet, just keep the current value of SB_Global,
 * if any.
 */
for (nb_global in nb.NB_Global) {
    sb.Out_SB_Global(.nb_cfg         = nb_global.nb_cfg,
                     .options        = nb_global.options,
                     .ipsec          = nb_global.ipsec)
}

sb.Out_SB_Global(.nb_cfg         = sb_global.nb_cfg,
                 .options        = sb_global.options,
                 .ipsec          = sb_global.ipsec) :-
    sb_global in sb.SB_Global(),
    not nb.NB_Global().

/*
 * NB_Global:
 * - set `sb_cfg` to the value of `SB_Global.nb_cfg`.
 * - set `hv_cfg` to the smallest value of `nb_cfg` across all `Chassis`
 * - FIXME: we use ipsec as unique key to make sure that we don't create multiple `NB_Global`
 *   instance.  There is a potential race condition if this field is modified at the same
 *   time northd is updating `sb_cfg` or `hv_cfg`.
 */
nb.Out_NB_Global(.sb_cfg        = sb_cfg,
                 .hv_cfg        = nb_cfg,
                 .ipsec         = ipsec,
                 .options       = options) :-
    nb.NB_Global(._uuid = nb_global_uuid, .ipsec = ipsec, .nb_cfg = nb_cfg, .options = opts),
    sb.SB_Global(.nb_cfg = sb_cfg),
    not sb.Chassis(),
    var options = match (map_get(opts, "mac_prefix")) {
        None -> {
            /* Hash NB_Global._uuid to obtain pseudo-random MAC prefix (in DDlog,
             * outputs must be functions of inputs, so no external sources of non-deteminism
             * are allowed.) */
            var mac_prefix = eth_addr_mark_random(eth_addr_from_uint64(hash64(nb_global_uuid)));
            map_insert_imm(opts, "mac_prefix", string_substr("${mac_prefix}", 0, 8))
        },
        _    -> opts
    }.

nb.Out_NB_Global(.sb_cfg        = sb_cfg,
                 .hv_cfg        = hv_cfg,
                 .ipsec         = ipsec,
                 .options       = options) :-
    nb.NB_Global(._uuid = nb_global_uuid, .ipsec = ipsec, .options = opts),
    sb.SB_Global(.nb_cfg = sb_cfg),
    sb.Chassis(.nb_cfg = chassis_cfg),
    var hv_cfg = Aggregate((nb_global_uuid, ipsec, sb_cfg, opts), group_min(chassis_cfg)),
    var options = match (map_get(opts, "mac_prefix")) {
        None -> {
            var mac_prefix = eth_addr_mark_random(eth_addr_from_uint64(hash64(nb_global_uuid)));
            map_insert_imm(opts, "mac_prefix", string_substr("${mac_prefix}", 0, 8))
        },
        _    -> opts
    }.

/* SB_Global does not exist yet -- just keep the old value of NB_Global */
nb.Out_NB_Global(.sb_cfg        = nb_global.sb_cfg,
                 .hv_cfg        = nb_global.hv_cfg,
                 .ipsec         = nb_global.ipsec,
                 .options       = nb_global.options) :-
    nb_global in nb.NB_Global(),
    not sb.SB_Global().

/*
 * Address_Set: copy from NB + additional records generated from NB Port_Group (two records for each
 * Port_Group for IPv4 and IPv6 addresses).
 *
 * There can be name collisions between the two types of Address_Set records.  User-defined records
 * take precedence.
 */
for (nb_as in nb.Address_Set) {
    sb.Out_Address_Set(.name      = nb_as.name,
                       .addresses = nb_as.addresses)
}

sb.Out_Address_Set(as_name, set_unions(pg_ip4addrs)) :-
    nb.Port_Group(.ports = pg_ports, .name = pg_name),
    var as_name = pg_name ++ "_ip4",
    // avoid name collisions with user-defined Address_Sets
    not nb.Address_Set(.name = as_name),
    var port_uuid = FlatMap(pg_ports),
    PortStaticAddresses(.lsport = port_uuid, .ip4addrs = stat),
    SwitchPortNewDynamicAddress(&SwitchPort{.lsp = nb.Logical_Switch_Port{._uuid = port_uuid}},
                                dyn_addr),
    var dynamic: Set<string> = match (dyn_addr) {
        None -> set_empty(),
        Some{lpaddress} -> match (vec_nth(lpaddress.ipv4_addrs, 0)) {
            None -> set_empty(),
            Some{addr} -> set_singleton(addr.addr_s)
        }
    },
    //PortDynamicAddresses(.lsport = port_uuid, .ip4addrs = dynamic),
    var port_ip4addrs: Set<string> = set_union(stat, dynamic),
    var pg_ip4addrs = Aggregate((as_name), group2vec(port_ip4addrs)).

sb.Out_Address_Set(as_name, set_empty()) :-
    nb.Port_Group(.ports = set_empty(), .name = pg_name),
    var as_name = pg_name ++ "_ip4",
    // avoid name collisions with user-defined Address_Sets
    not nb.Address_Set(.name = as_name).

sb.Out_Address_Set(as_name, set_unions(pg_ip6addrs)) :-
    nb.Port_Group(.ports = pg_ports, .name = pg_name),
    var as_name = pg_name ++ "_ip6",
    // avoid name collisions with user-defined Address_Sets
    not nb.Address_Set(.name = as_name),
    var port_uuid = FlatMap(pg_ports),
    PortStaticAddresses(.lsport = port_uuid, .ip6addrs = stat),
    SwitchPortNewDynamicAddress(&SwitchPort{.lsp = nb.Logical_Switch_Port{._uuid = port_uuid}},
                                dyn_addr),
    var dynamic: Set<string> = match (dyn_addr) {
        None -> set_empty(),
        Some{lpaddress} -> match (vec_nth(lpaddress.ipv6_addrs, 0)) {
            None -> set_empty(),
            Some{addr} -> set_singleton(addr.addr_s)
        }
    },
    //PortDynamicAddresses(.lsport = port_uuid, .ip6addrs = dynamic),
    var port_ip6addrs = set_union(stat, dynamic),
    var pg_ip6addrs = Aggregate((as_name), group2vec(port_ip6addrs)).

sb.Out_Address_Set(as_name, set_empty()) :-
    nb.Port_Group(.ports = set_empty(), .name = pg_name),
    var as_name = pg_name ++ "_ip6",
    // avoid name collisions with user-defined Address_Sets
    not nb.Address_Set(.name = as_name).

/*
 * Port_Group: copy from NB, but replace UUIDs with logical port names
 */
sb.Out_Port_Group(.name = pg_name, .ports = port_names) :-
    nb.Port_Group(.name = pg_name, .ports = pg_ports),
    var port_uuid = FlatMap(pg_ports),
    nb.Logical_Switch_Port(._uuid = port_uuid, .name = port_name),
    var port_names = Aggregate((pg_name), group2set(port_name)).

sb.Out_Port_Group(.name = pg_name, .ports = set_empty()) :-
    nb.Port_Group(.name = pg_name, .ports = set_empty()).


/*
 * Multicast_Group:
 * - three static rows per logical switch: one for flooding, one for packets
 *   with unknown destinations, one for flooding IP multicast known traffic to
 *   mrouters.
 * - dynamically created rows based on IGMP groups learned by controllers.
 */

function mC_FLOOD():         (string, integer) =
    ("_MC_flood", 64'd32768)

function mC_UNKNOWN():       (string, integer) =
    ("_MC_unknown", 64'd32769)

function mC_MROUTER_FLOOD(): (string, integer) =
    ("_MC_mrouter_flood", 64'd32770)

function mC_MROUTER_STATIC(): (string, integer) =
    ("_MC_mrouter_static", 64'd32771)

function mC_STATIC(): (string, integer) =
    ("_MC_static", 64'd32772)

function mC_IP_MCAST_MIN():  (string, integer) =
    ("_MC_ip_mcast_min", 64'd32773)

function mC_IP_MCAST_MAX():  (string, integer) =
    ("_MC_ip_mcast_max", 64'd65535)


// TODO: check that Multicast_Group.ports should not include derived ports

/* Only create flood group if the switch has enabled ports */
sb.Out_Multicast_Group (.datapath   = datapath,
                        .name       = name,
                        .tunnel_key = tunnel_key,
                        .ports      = set_map_uuid2name(port_ids)) :-
    &SwitchPort(.lsp = lsp, .sw = &Switch{.ls = ls}),
    is_enabled(lsp.enabled),
    var datapath = uuid2name(ls._uuid),
    var port_ids = Aggregate((datapath), group2set(lsp._uuid)),
    (var name, var tunnel_key) = mC_FLOOD().

/* Only create unknown group if the switch has ports with "unknown" address */
sb.Out_Multicast_Group (.datapath   = uuid2name(ls),
                        .name       = name,
                        .tunnel_key = tunnel_key,
                        .ports      = set_map_uuid2name(port_ids)) :-
    LogicalSwitchUnknownPorts(ls, port_ids),
    (var name, var tunnel_key) = mC_UNKNOWN().

/* Create a multicast group to flood multicast traffic to routers with
 * multicast relay enabled.
 */
sb.Out_Multicast_Group (.datapath = sw.dpname,
                        .name = name,
                        .tunnel_key = tunnel_key,
                        .ports = set_map_uuid2name(port_ids)) :-
    SwitchMcastFloodRelayPorts(&sw, port_ids), not set_is_empty(port_ids),
    (var name, var tunnel_key) = mC_MROUTER_FLOOD().

/* Create a multicast group to flood traffic (no reports) to ports with
 * multicast flood enabled.
 */
sb.Out_Multicast_Group (.datapath = sw.dpname,
                        .name = name,
                        .tunnel_key = tunnel_key,
                        .ports = set_map_uuid2name(port_ids)) :-
    SwitchMcastFloodPorts(&sw, port_ids), not set_is_empty(port_ids),
    (var name, var tunnel_key) = mC_STATIC().

/* Create a multicast group to flood reports to ports with
 * multicast flood_reports enabled.
 */
sb.Out_Multicast_Group (.datapath = sw.dpname,
                        .name = name,
                        .tunnel_key = tunnel_key,
                        .ports = set_map_uuid2name(port_ids)) :-
    SwitchMcastFloodReportPorts(&sw, port_ids), not set_is_empty(port_ids),
    (var name, var tunnel_key) = mC_MROUTER_STATIC().

/* Create a multicast group to flood traffic and reports to router ports with
 * multicast flood enabled.
 */
sb.Out_Multicast_Group (.datapath = rtr.dpname,
                        .name = name,
                        .tunnel_key = tunnel_key,
                        .ports = set_map_uuid2name(port_ids)) :-
    RouterMcastFloodPorts(&rtr, port_ids), not set_is_empty(port_ids),
    (var name, var tunnel_key) = mC_STATIC().

/* Create a multicast group for each IGMP group learned by a Switch.
 * 'tunnel_key' == 0 triggers an ID allocation later.
 */
sb.Out_Multicast_Group (.datapath   = switch.dpname,
                        .name       = address,
                        .tunnel_key = 0,
                        .ports      = set_map_uuid2name(port_ids)) :-
    IgmpSwitchMulticastGroup(address, &switch, port_ids).

/* Create a multicast group for each IGMP group learned by a Router.
 * 'tunnel_key' == 0 triggers an ID allocation later.
 */
sb.Out_Multicast_Group (.datapath   = router.dpname,
                        .name       = address,
                        .tunnel_key = 0,
                        .ports      = set_map_uuid2name(port_ids)) :-
    IgmpRouterMulticastGroup(address, &router, port_ids).

/* Bypass 'tunnel_key' allocation only for fixed multicast groups. */
sb.OutProxy_Multicast_Group(.datapath = mcgroup.datapath,
                            .name = mcgroup.name,
                            .tunnel_key = mcgroup.tunnel_key,
                            .ports = mcgroup.ports) :-
    sb.Swizzled_Multicast_Group[mcgroup],
    mcgroup.tunnel_key != 0.

/* Allocate a 'tunnel_key' for dynamic multicast groups. */
sb.OutProxy_Multicast_Group(.datapath = mcgroup.datapath,
                            .name = mcgroup.name,
                            .tunnel_key = tunnel_key,
                            .ports = mcgroup.ports) :-
    sb.Swizzled_Multicast_Group[mcgroup],
    mcgroup.tunnel_key == 0,
    MulticastGroupTunKeyAllocation(mcgroup.name, tunnel_key).

/*
 * MAC binding: records inserted by hypervisors; northd removes records for deleted logical ports
 */
sb.Out_MAC_Binding (.logical_port =   mb.logical_port,
                    .ip           =   mb.ip,
                    .mac          =   mb.mac,
                    .datapath     =   datapath_name) :-
    sb.MAC_Binding[mb],
    sb.Out_Port_Binding(.logical_port = mb.logical_port),
    sb.UUIDMap_Datapath_Binding(datapath_name, Left{mb.datapath}).


/*
 * DHCP options: fixed table
 */
sb.Out_DHCP_Options (
    .name   = "offerip",
    .code   = 0,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "netmask",
    .code   = 1,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "router",
    .code   = 3,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "dns_server",
    .code   = 6,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "log_server",
    .code   = 7,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "lpr_server",
    .code   = 9,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "swap_server",
    .code   = 16,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "policy_filter",
    .code   = 21,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "router_solicitation",
    .code   = 32,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "nis_server",
    .code   = 41,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "ntp_server",
    .code   = 42,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "server_id",
    .code   = 54,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "tftp_server",
    .code   = 66,
    .__type = "ipv4"
).

sb.Out_DHCP_Options (
    .name   = "classless_static_route",
    .code   = 121,
    .__type = "static_routes"
).

sb.Out_DHCP_Options (
    .name   = "ms_classless_static_route",
    .code   = 249,
    .__type = "static_routes"
).

sb.Out_DHCP_Options (
    .name   = "ip_forward_enable",
    .code   = 19,
    .__type = "bool"
).

sb.Out_DHCP_Options (
    .name   = "router_discovery",
    .code   = 31,
    .__type = "bool"
).

sb.Out_DHCP_Options (
    .name   = "ethernet_encap",
    .code   = 36,
    .__type = "bool"
).

sb.Out_DHCP_Options (
    .name   = "default_ttl",
    .code   = 23,
    .__type = "uint8"
).

sb.Out_DHCP_Options (
    .name   = "tcp_ttl",
    .code   = 37,
    .__type = "uint8"
).

sb.Out_DHCP_Options (
    .name   = "mtu",
    .code   = 26,
    .__type = "uint16"
).

sb.Out_DHCP_Options (
    .name   = "lease_time",
    .code   = 51,
    .__type = "uint32"
).

sb.Out_DHCP_Options (
    .name   = "T1",
    .code   = 58,
    .__type = "uint32"
).

sb.Out_DHCP_Options (
    .name   = "T2",
    .code   = 59,
    .__type = "uint32"
).

sb.Out_DHCP_Options (
    .name   = "bootfile_name",
    .code   = 67,
    .__type = "str"
).

sb.Out_DHCP_Options (
    .name   = "wpad",
    .code   = 252,
    .__type = "str"
).

sb.Out_DHCP_Options (
    .name   = "path_prefix",
    .code   = 210,
    .__type = "str"
).

sb.Out_DHCP_Options (
    .name   = "tftp_server_address",
    .code   = 150,
    .__type = "ipv4"
).


/*
 * DHCPv6 options: fixed table
 */
sb.Out_DHCPv6_Options (
    .name   = "server_id",
    .code   = 2,
    .__type = "mac"
).

sb.Out_DHCPv6_Options (
    .name   = "ia_addr",
    .code   = 5,
    .__type = "ipv6"
).

sb.Out_DHCPv6_Options (
    .name   = "dns_server",
    .code   = 23,
    .__type = "ipv6"
).

sb.Out_DHCPv6_Options (
    .name   = "domain_search",
    .code   = 24,
    .__type = "str"
).


/*
 * DNS: copied from NB + datapaths column pointer to LS datapaths that use the record
 */

sb.Out_DNS(.records      = nbdns.records,
           .datapaths    = datapaths,
           .external_ids = map_insert_imm(nbdns.external_ids, "dns_id", uuid2str(nbdns._uuid))) :-
    nb.DNS[nbdns],
    LogicalSwitchDNS(ls_uuid, nbdns._uuid),
    var datapaths = Aggregate((nbdns), group2set(uuid2name(ls_uuid))).

/*
 * RBAC_Permission: fixed
 */

sb.Out_RBAC_Permission (
    .uuid_name      = "u7df3749a_1754_4a78_afa4_3abf526fe510",
    .table          = "Chassis",
    .authorization  = set_singleton("name"),
    .insert_delete  = true,
    .update         = {
            var s: Set<string> = set_empty();
            set_insert(s, "nb_cfg");
            set_insert(s, "external_ids");
            set_insert(s, "encaps");
            set_insert(s, "vtep_logical_switches");
            s
        }
).

sb.Out_RBAC_Permission (
    .uuid_name      = "u94bec860_431e_4d95_82e7_3b75d8997241",
    .table          = "Encap",
    .authorization  = set_singleton("chassis_name"),
    .insert_delete  = true,
    .update         = {
            var s: Set<string> = set_empty();
            set_insert(s, "type");
            set_insert(s, "options");
            set_insert(s, "ip");
            s
        }
).

sb.Out_RBAC_Permission (
    .uuid_name      = "ud8ceff1a_2b11_48bd_802f_4a991aa4e908",
    .table          = "Port_Binding",
    .authorization  = set_singleton(""),
    .insert_delete  = false,
    .update         = set_singleton("chassis")
).

sb.Out_RBAC_Permission (
    .uuid_name      = "u6ffdc696_8bfb_4d82_b620_a00d39270b2f",
    .table          = "MAC_Binding",
    .authorization  = set_singleton(""),
    .insert_delete  = true,
    .update         = {
            var s: Set<string> = set_empty();
            set_insert(s, "logical_port");
            set_insert(s, "ip");
            set_insert(s, "mac");
            set_insert(s, "datapath");
            s
        }
).

/*
 * RBAC_Role: fixed
 */
sb.Out_RBAC_Role (
    .name        = "ovn-controller",
    .permissions = {
            var m: Map<string, string> = map_empty();
            map_insert(m, "Chassis"     , "u7df3749a_1754_4a78_afa4_3abf526fe510");
            map_insert(m, "Encap"       , "u94bec860_431e_4d95_82e7_3b75d8997241");
            map_insert(m, "Port_Binding", "ud8ceff1a_2b11_48bd_802f_4a991aa4e908");
            map_insert(m, "MAC_Binding" , "u6ffdc696_8bfb_4d82_b620_a00d39270b2f");
            m
        }
).

/* Output modified Logical_Switch_Port table with dynamic address updated */
nb.Out_Logical_Switch_Port(.uuid_name              = uuid2name(lsp._uuid),
                           .name                   = lsp.name,
                           .__type                 = lsp.__type,
                           .options                = lsp.options,
                           .parent_name            = lsp.parent_name,
                           .tag_request            = lsp.tag_request,
                           .tag                    = tag,
                           .addresses              = lsp.addresses,
                           .dynamic_addresses      = dynamic_addresses,
                           .port_security          = lsp.port_security,
                           .up                     = set_singleton(up),
                           .enabled                = lsp.enabled,
                           .dhcpv4_options         = lsp.dhcpv4_options,
                           .dhcpv6_options         = lsp.dhcpv6_options,
                           .ha_chassis_group       = set_empty(),
                           .external_ids           = lsp.external_ids) :-
    SwitchPortNewDynamicAddress(&SwitchPort{.lsp = lsp, .up = up}, opt_dyn_addr),
    var dynamic_addresses: Set<string> = match (opt_dyn_addr) {
        None -> set_empty(),
        Some{dyn_addr} -> set_singleton("${dyn_addr}")
    },
    SwitchPortNewDynamicTag(lsp._uuid, opt_tag),
    var tag: Set<integer> = match (opt_tag) {
        None -> lsp.tag,
        Some{t} -> set_singleton(t)
    }.

typedef Direction = IN | OUT

typedef PipelineStage = PORT_SEC_L2
                      | PORT_SEC_IP
                      | PORT_SEC_ND
                      | PRE_ACL
                      | PRE_LB
                      | PRE_STATEFUL
                      | ACL
                      | QOS_MARK
                      | QOS_METER
                      | LB
                      | STATEFUL
                      | ARP_ND_RSP
                      | DHCP_OPTIONS
                      | DHCP_RESPONSE
                      | DNS_LOOKUP
                      | DNS_RESPONSE
                      | L2_LKUP
                      | ADMISSION
                      | IP_INPUT
                      | DEFRAG
                      | UNSNAT
                      | DNAT
                      | ND_RA_OPTIONS
                      | ND_RA_RESPONSE
                      | IP_ROUTING
                      | ARP_RESOLVE
                      | GW_REDIRECT
                      | ARP_REQUEST
                      | UNDNAT
                      | SNAT
                      | EGR_LOOP
                      | DELIVERY

typedef DatapathType = LSwitch | LRouter

typedef Stage = Stage{
    datapath    : DatapathType,
    direction   : Direction,
    stage       : PipelineStage
}

function switch_stage(direction: Direction, stage: PipelineStage): Stage = {
    Stage{LSwitch, direction, stage}
}

function router_stage(direction: Direction, stage: PipelineStage): Stage = {
    Stage{LRouter, direction, stage}
}

function stage_id(stage: Stage): (integer, string) =
{
    match ((stage.datapath, stage.direction, stage.stage)) {
        /* Logical switch ingress stages. */
        (LSwitch, IN,  PORT_SEC_L2)   -> (0,  "ls_in_port_sec_l2"),
        (LSwitch, IN,  PORT_SEC_IP)   -> (1,  "ls_in_port_sec_ip"),
        (LSwitch, IN,  PORT_SEC_ND)   -> (2,  "ls_in_port_sec_nd"),
        (LSwitch, IN,  PRE_ACL)       -> (3,  "ls_in_pre_acl"),
        (LSwitch, IN,  PRE_LB)        -> (4,  "ls_in_pre_lb"),
        (LSwitch, IN,  PRE_STATEFUL)  -> (5,  "ls_in_pre_stateful"),
        (LSwitch, IN,  ACL)           -> (6,  "ls_in_acl"),
        (LSwitch, IN,  QOS_MARK)      -> (7,  "ls_in_qos_mark"),
        (LSwitch, IN,  QOS_METER)     -> (8,  "ls_in_qos_meter"),
        (LSwitch, IN,  LB)            -> (9,  "ls_in_lb"),
        (LSwitch, IN,  STATEFUL)      -> (10, "ls_in_stateful"),
        (LSwitch, IN,  ARP_ND_RSP)    -> (11, "ls_in_arp_rsp"),
        (LSwitch, IN,  DHCP_OPTIONS)  -> (12, "ls_in_dhcp_options"),
        (LSwitch, IN,  DHCP_RESPONSE) -> (13, "ls_in_dhcp_response"),
        (LSwitch, IN,  DNS_LOOKUP)    -> (14, "ls_in_dns_lookup"),
        (LSwitch, IN,  DNS_RESPONSE)  -> (15, "ls_in_dns_response"),
        (LSwitch, IN,  L2_LKUP)       -> (16, "ls_in_l2_lkup"),

        /* Logical switch egress stages. */
        (LSwitch, OUT, PRE_LB)        -> (0,  "ls_out_pre_lb"),
        (LSwitch, OUT, PRE_ACL)       -> (1,  "ls_out_pre_acl"),
        (LSwitch, OUT, PRE_STATEFUL)  -> (2,  "ls_out_pre_stateful"),
        (LSwitch, OUT, LB)            -> (3,  "ls_out_lb"),
        (LSwitch, OUT, ACL)           -> (4,  "ls_out_acl"),
        (LSwitch, OUT, QOS_MARK)      -> (5,  "ls_out_qos_mark"),
        (LSwitch, OUT, QOS_METER)     -> (6,  "ls_out_qos_meter"),
        (LSwitch, OUT, STATEFUL)      -> (7,  "ls_out_stateful"),
        (LSwitch, OUT, PORT_SEC_IP)   -> (8,  "ls_out_port_sec_ip"),
        (LSwitch, OUT, PORT_SEC_L2)   -> (9,  "ls_out_port_sec_l2"),

        /* Logical router ingress stages. */
        (LRouter, IN,  ADMISSION)     -> (0,  "lr_in_admission"),
        (LRouter, IN,  IP_INPUT)      -> (1,  "lr_in_ip_input"),
        (LRouter, IN,  DEFRAG)        -> (2,  "lr_in_defrag"),
        (LRouter, IN,  UNSNAT)        -> (3,  "lr_in_unsnat"),
        (LRouter, IN,  DNAT)          -> (4,  "lr_in_dnat"),
        (LRouter, IN,  ND_RA_OPTIONS) -> (5,  "lr_in_nd_ra_options"),
        (LRouter, IN,  ND_RA_RESPONSE)-> (6,  "lr_in_nd_ra_response"),
        (LRouter, IN,  IP_ROUTING)    -> (7,  "lr_in_ip_routing"),
        (LRouter, IN,  ARP_RESOLVE)   -> (8,  "lr_in_arp_resolve"),
        (LRouter, IN,  GW_REDIRECT)   -> (9,  "lr_in_gw_redirect"),
        (LRouter, IN,  ARP_REQUEST)   -> (10, "lr_in_arp_request"),

        /* Logical router egress stages. */
        (LRouter, OUT, UNDNAT)        -> (0,  "lr_out_undnat"),
        (LRouter, OUT, SNAT)          -> (1,  "lr_out_snat"),
        (LRouter, OUT, EGR_LOOP)      -> (2,  "lr_out_egr_loop"),
        (LRouter, OUT, DELIVERY)      -> (3,  "lr_out_delivery"),

        _                             -> (64'hffffffffffffffff, "") /* alternatively crash? */
    }
}


/* Register definitions specific to switches. */
function rEGBIT_CONNTRACK_DEFRAG() : string = "reg0[0]"
function rEGBIT_CONNTRACK_COMMIT() : string = "reg0[1]"
function rEGBIT_CONNTRACK_NAT()    : string = "reg0[2]"
function rEGBIT_DHCP_OPTS_RESULT() : string = "reg0[3]"
function rEGBIT_DNS_LOOKUP_RESULT(): string = "reg0[4]"
function rEGBIT_ND_RA_OPTS_RESULT(): string = "reg0[5]"

/* Register definitions for switches and routers. */
function rEGBIT_NAT_REDIRECT()     : string = "reg9[0]"
/* Indicate that this packet has been recirculated using egress
 * loopback.  This allows certain checks to be bypassed, such as a
 * logical router dropping packets with source IP address equals
 * one of the logical router's own IP addresses. */
function rEGBIT_EGRESS_LOOPBACK()  : string = "reg9[1]"

function mFF_N_LOG_REGS()          : bit<32> = 10

/*
 * Logical_Flow
   relation Out_Logical_Flow (
        logical_datapath: string,
        pipeline: string,
        table_id: integer,
        priority: integer,
        __match: string,
        actions: string,
        external_ids: Map<string,string>)
 */

relation Flow (
    logical_datapath: string,
    stage:            Stage,
    priority:         integer,
    __match:          string,
    actions:          string,
    external_ids:     Map<string,string>
)

sb.Out_Logical_Flow(.logical_datapath = f.logical_datapath,
                    .pipeline         = if (f.stage.direction == IN) "ingress" else "egress",
                    .table_id         = table_id,
                    .priority         = f.priority,
                    .__match          = f.__match,
                    .actions          = f.actions,
                    .external_ids     = map_insert_imm(f.external_ids, "stage-name", table_name)) :-
    Flow[f],
    (var table_id, var table_name) = stage_id(f.stage).

/* Logical switch ingress table 0: admission control framework (priority 100) */
for (&Switch(.dpname = dpname)) {
    /* Logical VLANs not supported */
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(IN, PORT_SEC_L2),
         .priority         = 100,
         .__match          = "vlan.present",
         .actions          = "drop;",
         .external_ids     = map_empty() /*TODO: check*/);

    /* Broadcast/multicast source address is invalid */
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(IN, PORT_SEC_L2),
         .priority         = 100,
         .__match          = "eth.src[40]",
         .actions          = "drop;",
         .external_ids     = map_empty() /*TODO: check*/)
    /* Port security flows have priority 50 (see below) and will continue to the next table
       if packet source is acceptable. */
}

// space-separated vector of strings
function vec_space_sep(items: Vec<string>): string = {
    string_join(items, " ")
}

// space-separated set of strings
function set_space_sep(items: Set<string>): string = {
    vec_space_sep(set2vec(items))
}

function build_port_security_ipv6_flow(
    pipeline: Direction,
    ea: eth_addr,
    ipv6_addrs: Vec<ipv6_netaddr>): string =
{
    var ip6_addrs: Vec<string> = vec_empty();

    /* Allow link-local address. */
    vec_push(ip6_addrs, ipv6_string_mapped(in6_generate_lla(ea)));

    /* Allow ip6.dst=ff00::/8 for multicast packets */
    if (pipeline == OUT) {
        vec_push(ip6_addrs, "ff00::/8")
    } else ();
    for (addr in ipv6_addrs) {
        vec_push(ip6_addrs, ipv6_string_mapped(addr.addr))
    };

    " && ${if (pipeline == IN) \"ip6.src\" else \"ip6.dst\"} == {${string_join(ip6_addrs, \", \")}}"
}

function build_port_security_ipv6_nd_flow(
    ea: eth_addr,
    ipv6_addrs: Vec<ipv6_netaddr>): string =
{
    var __match = " && ip6 && nd && ((nd.sll == ${eth_addr_zero()} || "
                  "nd.sll == ${ea}) || ((nd.tll == ${eth_addr_zero()} || "
                  "nd.tll == ${ea})";
    if (vec_is_empty(ipv6_addrs)) {
        __match ++ "))"
    } else {
        var ip6_str = ipv6_string_mapped(in6_generate_lla(ea));
        __match = __match ++ " && (nd.target == ${ip6_str}";

        for(addr in ipv6_addrs) {
            ip6_str = ipv6_string_mapped(addr.addr);
            __match = __match ++ " || nd.target == ${ip6_str}"
        };
        __match ++ ")))"
    }
}

/* Pre-ACL */
for (&Switch(.ls =ls, .dpname = dpname)) {
    /* Ingress and Egress Pre-ACL Table (Priority 0): Packets are
     * allowed by default. */
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(IN, PRE_ACL),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty());
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(OUT, PRE_ACL),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty())
}


/* If there are any stateful ACL rules in this datapath, we must
 * send all IP packets through the conntrack action, which handles
 * defragmentation, in order to match L4 headers. */

for (&SwitchPort(.lsp = lsp@nb.Logical_Switch_Port{.__type = "router"},
                 .json_name = lsp_name,
                 .sw = &Switch{.dpname = dpname, .has_stateful_acl = true})) {
    /* Can't use ct() for router ports. Consider the
     * following configuration: lp1(10.0.0.2) on
     * hostA--ls1--lr0--ls2--lp2(10.0.1.2) on hostB, For a
     * ping from lp1 to lp2, First, the response will go
     * through ct() with a zone for lp2 in the ls2 ingress
     * pipeline on hostB.  That ct zone knows about this
     * connection. Next, it goes through ct() with the zone
     * for the router port in the egress pipeline of ls2 on
     * hostB.  This zone does not know about the connection,
     * as the icmp request went through the logical router
     * on hostA, not hostB. This would only work with
     * distributed conntrack state across all chassis. */
    // FIXME: is this check redundant?
    Some{var router_port} = map_get(lsp.options, "router-port") in {
        Flow(.logical_datapath = dpname,
             .stage         = switch_stage(IN, PRE_ACL),
             .priority         = 110,
             .__match          = "ip && inport == ${lsp_name}",
             .actions          = "next;",
             .external_ids     = map_empty());
        Flow(.logical_datapath = dpname,
             .stage         = switch_stage(OUT, PRE_ACL),
             .priority         = 110,
             .__match          = "ip && outport == ${lsp_name}",
             .actions          = "next;",
             .external_ids     = map_empty())
    }
}

for (&SwitchPort(.lsp = nb.Logical_Switch_Port{.__type = "localnet"},
                 .json_name = lsp_name,
                 .sw = &Switch{.dpname = dpname, .has_stateful_acl = true})) {
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(IN, PRE_ACL),
         .priority         = 110,
         .__match          = "ip && inport == ${lsp_name}",
         .actions          = "next;",
         .external_ids     = map_empty());
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(OUT, PRE_ACL),
         .priority         = 110,
         .__match          = "ip && outport == ${lsp_name}",
         .actions          = "next;",
         .external_ids     = map_empty())
}

for (&Switch(.dpname = dpname, .has_stateful_acl = true)) {
    /* Ingress and Egress Pre-ACL Table (Priority 110).
     *
     * Not to do conntrack on ND and ICMP destination
     * unreachable packets. */
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(IN, PRE_ACL),
         .priority         = 110,
         .__match          = "nd || nd_rs || nd_ra || icmp4.type == 3 || "
                             "icmp6.type == 1 || (tcp && tcp.flags == 4)",
         .actions          = "next;",
         .external_ids     = map_empty());
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(OUT, PRE_ACL),
         .priority         = 110,
         .__match          = "nd || nd_rs || nd_ra || icmp4.type == 3 || "
                             "icmp6.type == 1 || (tcp && tcp.flags == 4)",
         .actions          = "next;",
         .external_ids     = map_empty());

    /* Ingress and Egress Pre-ACL Table (Priority 100).
     *
     * Regardless of whether the ACL is "from-lport" or "to-lport",
     * we need rules in both the ingress and egress table, because
     * the return traffic needs to be followed.
     *
     * 'REGBIT_CONNTRACK_DEFRAG' is set to let the pre-stateful table send
     * it to conntrack for tracking and defragmentation. */
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(IN, PRE_ACL),
         .priority         = 100,
         .__match          = "ip",
         .actions          = "${rEGBIT_CONNTRACK_DEFRAG()} = 1; next;",
         .external_ids     = map_empty());
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(OUT, PRE_ACL),
         .priority         = 100,
         .__match          = "ip",
         .actions          = "${rEGBIT_CONNTRACK_DEFRAG()} = 1; next;",
         .external_ids     = map_empty())
}

/* Pre-LB */
for (&Switch(.dpname = dpname)) {
    /* Do not send ND packets to conntrack */
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(IN, PRE_LB),
         .priority         = 110,
         .__match          = "nd || nd_rs || nd_ra",
         .actions          = "next;",
         .external_ids     = map_empty());
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(OUT, PRE_LB),
         .priority         = 110,
         .__match          = "nd || nd_rs || nd_ra",
         .actions          = "next;",
         .external_ids     = map_empty());

    /* Allow all packets to go to next tables by default. */
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(IN, PRE_LB),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty());
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(OUT, PRE_LB),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty())
}

relation HasEventElbMeter(has_meter: bool)

HasEventElbMeter(true) :-
    nb.Meter(.name = "event-elb").

HasEventElbMeter(false) :-
    nb.NB_Global(._uuid = uuid),
    not nb.Meter(.name = "event-elb").

/* Empty LoadBalancer Controller event */
function build_empty_lb_event_flow(key: string, lb: nb.Load_Balancer,
                                   meter: bool):
         Option<(string, string)> = {
    var __proto = if (set_nth(lb.protocol, 0) == Some{"tcp"}) {
        "tcp"
    } else {
        "udp"
    };
    var __meter = if (meter) {
        "event-elb"
    } else {
        ""
    };
    var __action = "trigger_event(event = \"empty_lb_backends\", \
                    \meter = \"${__meter}\", protocol = \"${__proto}\", ";
    var __uuid = uuid2str(lb._uuid);
    var __match = "";

    match (ip_address_and_port_from_lb_key(key)) {
        Some{(ip_address_, port_, addr_family_)} -> {
            __action = __action ++ "load_balancer = \"${__uuid}\", \
                       \vip = \"${ip_address_}";
            if (addr_family_ == aF_INET()) {
                __match = "ip4.dst == ${ip_address_}"
            } else {
                __match = "ip6.dst == ${ip_address_}"
            };
            if (port_ != 0) {
                __action = __action ++ ":${port_}\");";
                __match = __match ++ " && ${__proto} && ${__proto}.dst == ${port_}"
            } else {
                __action = __action ++ "\");"
            }
            },
        None -> ()
    };
    Some{(__match, __action)}
}

for (SwitchLBVIP(.sw = &sw, .lb = &lb, .vip = (vip_key, vip_val))) {
    if (vip_val == "") {
            for (HasEventElbMeter(has_elb_meter)) {
                Some {(var __match, var __action)} =
                    build_empty_lb_event_flow(vip_key, lb, has_elb_meter) in
                    Flow(.logical_datapath = sw.dpname,
                         .stage            = switch_stage(IN, PRE_LB),
                         .priority         = 130,
                         .__match          = __match,
                         .actions          = __action,
                         .external_ids     = map_empty())
            }
    }
}

/* 'REGBIT_CONNTRACK_DEFRAG' is set to let the pre-stateful table send
 * packet to conntrack for defragmentation. */

for (SwitchLBVIP(.sw = &sw, .vip = vip)) {
    (var k, _) = vip in
    /* Ignore L4 port information in the key because fragmented packets
     * may not have L4 information.  The pre-stateful table will send
     * the packet through ct() action to de-fragment. In stateful
     * table, we will eventually look at L4 information. */
    Some{(var ip_address, _, var addr_family)} = ip_address_and_port_from_lb_key(k) in
    var __match = if (addr_family == aF_INET()) {
           "ip && ip4.dst == ${ip_address}"
        } else {
           "ip && ip6.dst == ${ip_address}"
        } in
    Flow(.logical_datapath = sw.dpname,
         .stage         = switch_stage(IN, PRE_LB),
         .priority         = 100,
         .__match          = __match,
         .actions          = "${rEGBIT_CONNTRACK_DEFRAG()} = 1; next;",
         .external_ids     = map_empty())
}

for (SwitchHasLBVIP(&sw)) {
    Flow(.logical_datapath = sw.dpname,
         .stage         = switch_stage(OUT, PRE_LB),
         .priority         = 100,
         .__match          = "ip",
         .actions          = "${rEGBIT_CONNTRACK_DEFRAG()} = 1; next;",
         .external_ids     = map_empty())
}

/* Pre-stateful */
for (&Switch(.dpname = dpname)) {
    /* Ingress and Egress pre-stateful Table (Priority 0): Packets are
     * allowed by default. */
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(IN, PRE_STATEFUL),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty());
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(OUT, PRE_STATEFUL),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty());

    /* If REGBIT_CONNTRACK_DEFRAG is set as 1, then the packets should be
     * sent to conntrack for tracking and defragmentation. */
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(IN, PRE_STATEFUL),
         .priority         = 100,
         .__match          = "${rEGBIT_CONNTRACK_DEFRAG()} == 1",
         .actions          = "ct_next;",
         .external_ids     = map_empty());
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(OUT, PRE_STATEFUL),
         .priority         = 100,
         .__match          = "${rEGBIT_CONNTRACK_DEFRAG()} == 1",
         .actions          = "ct_next;",
         .external_ids     = map_empty())
}

function build_acl_log(acl: nb.ACL): string =
{
    if (not acl.log) {
        ""
    } else {
        var strs: Vec<string> = vec_empty();
        match (set_nth(acl.name, 0)) {
            None -> (),
            Some{name} -> vec_push(strs, "name=\"${name}\"")
        };
        /* If a severity level isn't specified, default to "info". */
        match (set_nth(acl.severity, 0)) {
            None -> vec_push(strs, "severity=info"),
            Some{severity} -> vec_push(strs, "severity=${severity}")
        };
        match (acl.action) {
            "drop" -> {
                vec_push(strs, "verdict=drop")
            },
            "reject" -> {
                vec_push(strs, "verdict=reject")
            },
            "allow" -> {
                vec_push(strs, "verdict=allow")
            },
            "allow-related" -> {
                vec_push(strs, "verdict=allow")
            },
            _ -> ()
        };
        match (set_nth(acl.meter, 0)) {
            None -> (),
            Some{meter} -> vec_push(strs, "meter=${meter}")
        };
        "log(${string_join(strs, \", \")}); "
    }
}

/* Due to various hard-coded priorities need to implement ACLs, the
 * northbound database supports a smaller range of ACL priorities than
 * are available to logical flows.  This value is added to an ACL
 * priority to determine the ACL's logical flow priority. */
function oVN_ACL_PRI_OFFSET(): integer = 1000

/* Intermediate relation that stores reject ACLs.
 * The following rules generate logical flows for these ACLs.
 */
relation Reject(lsname: string, pipeline: string, stage: Stage, acl: nb.ACL, extra_match: string, extra_actions: string)

/* build_reject_acl_rules() */
for (Reject(lsname, pipeline, stage, acl, extra_match, extra_actions)) {
    var ingress = (pipeline == "ingress") in {
        /* TCP */
        var __match = if (extra_match != "") {
                "(${extra_match}) && "
            } else {
                ""
            } ++ "ip4 && tcp && (${acl.__match})" in
        var actions = "${build_acl_log(acl)}reg0 = 0; "
                      "eth.dst <-> eth.src; ip4.dst <-> ip4.src; "
                      "tcp_reset { outport <-> inport; ${if ingress \"output;\" else \"next(pipeline=ingress,table=0);\"} };" in
        Flow(.logical_datapath = lsname,
             .stage            = stage,
             .priority         = acl.priority + oVN_ACL_PRI_OFFSET() + 10,
             .__match          = __match,
             .actions          = actions,
             .external_ids     = map_empty());

        var __match = if (extra_match != "") {
                "(${extra_match}) && "
            } else { "" } ++
            "ip6 && tcp && (${acl.__match})" in
        var actions = "${build_acl_log(acl)}reg0 = 0; "
                      "eth.dst <-> eth.src; ip6.dst <-> ip6.src; "
                      "tcp_reset { outport <-> inport; ${if ingress \"output;\" else \"next(pipeline=ingress,table=0);\"} };" in
        Flow(.logical_datapath = lsname,
             .stage         = stage,
             .priority         = acl.priority + oVN_ACL_PRI_OFFSET() + 10,
             .__match          = __match,
             .actions          = actions,
             .external_ids     = map_empty());

        /* IP traffic */
        var __match = if (extra_match != "") {
                "(${extra_match}) && "
            } else { "" } ++
            "ip4 && (${acl.__match})" in
        var actions = build_acl_log(acl) ++
                      if (extra_actions != "") {
                          "${extra_actions} "
                      } else { "" } ++
                      "reg0 = 0; eth.dst <-> eth.src; ip4.dst <-> ip4.src; "
                      "icmp4 { outport <-> inport; ${if ingress \"output;\" else \"next(pipeline=ingress,table=0);\"} };" in
        Flow(.logical_datapath = lsname,
             .stage         = stage,
             .priority         = acl.priority + oVN_ACL_PRI_OFFSET(),
             .__match          = __match,
             .actions          = actions,
             .external_ids     = map_empty());

        var __match = if (extra_match != "") {
                "(${extra_match}) && "
            } else { "" } ++
            "ip6 && (${acl.__match})" in
        var actions = build_acl_log(acl) ++
                      if (extra_actions != "") {
                          "${extra_actions} "
                      } else { "" } ++
                      "reg0 = 0; icmp6 { "
                      "eth.dst <-> eth.src; ip6.dst <-> ip6.src; "
                      "outport <-> inport; ${if ingress \"output;\" else \"next(pipeline=ingress,table=0);\"} };" in
        Flow(.logical_datapath = lsname,
             .stage         = stage,
             .priority         = acl.priority + oVN_ACL_PRI_OFFSET(),
             .__match          = __match,
             .actions          = actions,
             .external_ids     = map_empty())
    }
}

/* build_acls */
for (&Switch(.ls = ls,
             .dpname = dpname,
             .has_stateful_acl = has_stateful,
             .has_dns_records = has_dns_records)) {
    /* Ingress and Egress ACL Table (Priority 0): Packets are allowed by
     * default.  A related rule at priority 1 is added below if there
     * are any stateful ACLs in this datapath. */
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(IN, ACL),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty());
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(OUT, ACL),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty());

    if (has_stateful) {
        /* Ingress and Egress ACL Table (Priority 1).
         *
         * By default, traffic is allowed.  This is partially handled by
         * the Priority 0 ACL flows added earlier, but we also need to
         * commit IP flows.  This is because, while the initiater's
         * direction may not have any stateful rules, the server's may
         * and then its return traffic would not have an associated
         * conntrack entry and would return "+invalid".
         *
         * We use "ct_commit" for a connection that is not already known
         * by the connection tracker.  Once a connection is committed,
         * subsequent packets will hit the flow at priority 0 that just
         * uses "next;"
         *
         * We also check for established connections that have ct_label.blocked
         * set on them.  That's a connection that was disallowed, but is
         * now allowed by policy again since it hit this default-allow flow.
         * We need to set ct_label.blocked=0 to let the connection continue,
         * which will be done by ct_commit() in the "stateful" stage.
         * Subsequent packets will hit the flow at priority 0 that just
         * uses "next;". */
        Flow(.logical_datapath = dpname,
             .stage         = switch_stage(IN, ACL),
             .priority         = 1,
             .__match          = "ip && (!ct.est || (ct.est && ct_label.blocked == 1))",
             .actions          = "${rEGBIT_CONNTRACK_COMMIT()} = 1; next;",
             .external_ids     = map_empty());
        Flow(.logical_datapath = dpname,
             .stage         = switch_stage(OUT, ACL),
             .priority         = 1,
             .__match          = "ip && (!ct.est || (ct.est && ct_label.blocked == 1))",
             .actions          = "${rEGBIT_CONNTRACK_COMMIT()} = 1; next;",
             .external_ids     = map_empty());

        /* Ingress and Egress ACL Table (Priority 65535).
         *
         * Always drop traffic that's in an invalid state.  Also drop
         * reply direction packets for connections that have been marked
         * for deletion (bit 0 of ct_label is set).
         *
         * This is enforced at a higher priority than ACLs can be defined. */
        Flow(.logical_datapath = dpname,
             .stage         = switch_stage(IN, ACL),
             .priority         = 65535,
             .__match          = "ct.inv || (ct.est && ct.rpl && ct_label.blocked == 1)",
             .actions          = "drop;",
             .external_ids     = map_empty());
        Flow(.logical_datapath = dpname,
             .stage         = switch_stage(OUT, ACL),
             .priority         = 65535,
             .__match          = "ct.inv || (ct.est && ct.rpl && ct_label.blocked == 1)",
             .actions          = "drop;",
             .external_ids     = map_empty());

        /* Ingress and Egress ACL Table (Priority 65535).
         *
         * Allow reply traffic that is part of an established
         * conntrack entry that has not been marked for deletion
         * (bit 0 of ct_label).  We only match traffic in the
         * reply direction because we want traffic in the request
         * direction to hit the currently defined policy from ACLs.
         *
         * This is enforced at a higher priority than ACLs can be defined. */
        Flow(.logical_datapath = dpname,
             .stage         = switch_stage(IN, ACL),
             .priority         = 65535,
             .__match          = "ct.est && !ct.rel && !ct.new && !ct.inv "
                                 "&& ct.rpl && ct_label.blocked == 0",
             .actions          = "next;",
             .external_ids     = map_empty());
        Flow(.logical_datapath = dpname,
             .stage         = switch_stage(OUT, ACL),
             .priority         = 65535,
             .__match          = "ct.est && !ct.rel && !ct.new && !ct.inv "
                                 "&& ct.rpl && ct_label.blocked == 0",
             .actions          = "next;",
             .external_ids     = map_empty());

        /* Ingress and Egress ACL Table (Priority 65535).
         *
         * Allow traffic that is related to an existing conntrack entry that
         * has not been marked for deletion (bit 0 of ct_label).
         *
         * This is enforced at a higher priority than ACLs can be defined.
         *
         * NOTE: This does not support related data sessions (eg,
         * a dynamically negotiated FTP data channel), but will allow
         * related traffic such as an ICMP Port Unreachable through
         * that's generated from a non-listening UDP port.  */
        Flow(.logical_datapath = dpname,
             .stage         = switch_stage(IN, ACL),
             .priority         = 65535,
             .__match          = "!ct.est && ct.rel && !ct.new && !ct.inv "
                                 "&& ct_label.blocked == 0",
             .actions          = "next;",
             .external_ids     = map_empty());
        Flow(.logical_datapath = dpname,
             .stage         = switch_stage(OUT, ACL),
             .priority         = 65535,
             .__match          = "!ct.est && ct.rel && !ct.new && !ct.inv "
                                 "&& ct_label.blocked == 0",
             .actions          = "next;",
             .external_ids     = map_empty());

        /* Ingress and Egress ACL Table (Priority 65535).
         *
         * Not to do conntrack on ND packets. */
        Flow(.logical_datapath = dpname,
             .stage         = switch_stage(IN, ACL),
             .priority         = 65535,
             .__match          = "nd",
             .actions          = "next;",
             .external_ids     = map_empty());
        Flow(.logical_datapath = dpname,
             .stage         = switch_stage(OUT, ACL),
             .priority         = 65535,
             .__match          = "nd",
             .actions          = "next;",
             .external_ids     = map_empty())
    };

    /* Add a 34000 priority flow to advance the DNS reply from ovn-controller,
     * if the CMS has configured DNS records for the datapath.
     */
    if (has_dns_records) {
        Flow(.logical_datapath = dpname,
             .stage         = switch_stage(OUT, ACL),
             .priority         = 34000,
             .__match          = "udp.src == 53",
             .actions          = if has_stateful "ct_commit; next;" else "next;",
             .external_ids     = map_empty())
    }
}

/* Ingress or Egress ACL Table (Various priorities). */
for (&SwitchACL(.sw = &Switch{.ls = ls, .dpname = dpname, .has_stateful_acl = has_stateful},
                .acl = &acl)) {
    /* consider_acl */
    var ingress = acl.direction == "from-lport" in
    var stage = if ingress switch_stage(IN, ACL) else switch_stage(OUT, ACL) in
    var pipeline = if ingress "ingress" else "egress" in
    var stage_hint = map_singleton("stage-hint", "${hex(acl._uuid[127:96])}") in
    if (acl.action == "allow" or acl.action == "allow-related") {
        /* If there are any stateful flows, we must even commit "allow"
         * actions.  This is because, while the initiater's
         * direction may not have any stateful rules, the server's
         * may and then its return traffic would not have an
         * associated conntrack entry and would return "+invalid". */
        if (not has_stateful) {
            Flow(.logical_datapath = dpname,
                 .stage         = stage,
                 .priority         = acl.priority + oVN_ACL_PRI_OFFSET(),
                 .__match          = acl.__match,
                 .actions          = "${build_acl_log(acl)}next;",
                 .external_ids     = stage_hint)
        } else {
            /* Commit the connection tracking entry if it's a new
             * connection that matches this ACL.  After this commit,
             * the reply traffic is allowed by a flow we create at
             * priority 65535, defined earlier.
             *
             * It's also possible that a known connection was marked for
             * deletion after a policy was deleted, but the policy was
             * re-added while that connection is still known.  We catch
             * that case here and un-set ct_label.blocked (which will be done
             * by ct_commit in the "stateful" stage) to indicate that the
             * connection should be allowed to resume.
             */
            Flow(.logical_datapath = dpname,
                 .stage         = stage,
                 .priority         = acl.priority + oVN_ACL_PRI_OFFSET(),
                 .__match          = "((ct.new && !ct.est) || (!ct.new && ct.est && !ct.rpl "
                                     "&& ct_label.blocked == 1)) && (${acl.__match})",
                 .actions          = "${rEGBIT_CONNTRACK_COMMIT()} = 1; ${build_acl_log(acl)}next;",
                 .external_ids     = stage_hint);

            /* Match on traffic in the request direction for an established
             * connection tracking entry that has not been marked for
             * deletion.  There is no need to commit here, so we can just
             * proceed to the next table. We use this to ensure that this
             * connection is still allowed by the currently defined
             * policy. */
            Flow(.logical_datapath = dpname,
                 .stage         = stage,
                 .priority         = acl.priority + oVN_ACL_PRI_OFFSET(),
                 .__match          = "!ct.new && ct.est && !ct.rpl"
                                     " && ct_label.blocked == 0 && (${acl.__match})",
                 .actions          = "${build_acl_log(acl)}next;",
                 .external_ids     = stage_hint)
        }
    } else if (acl.action == "drop" or acl.action == "reject") {
        /* The implementation of "drop" differs if stateful ACLs are in
         * use for this datapath.  In that case, the actions differ
         * depending on whether the connection was previously committed
         * to the connection tracker with ct_commit. */
        if (has_stateful) {
            /* If the packet is not part of an established connection, then
             * we can simply reject/drop it. */
            var __match = "(!ct.est || (ct.est && ct_label.blocked == 1))" in
            if (acl.action == "reject") {
                Reject(dpname, pipeline, stage, acl, __match, "")
            } else {
                Flow(.logical_datapath = dpname,
                     .stage         = stage,
                     .priority         = acl.priority + oVN_ACL_PRI_OFFSET(),
                     .__match          = __match ++ " && (${acl.__match})",
                     .actions          = "${build_acl_log(acl)}/* drop */",
                     .external_ids     = stage_hint)
            };
            /* For an existing connection without ct_label set, we've
             * encountered a policy change. ACLs previously allowed
             * this connection and we committed the connection tracking
             * entry.  Current policy says that we should drop this
             * connection.  First, we set bit 0 of ct_label to indicate
             * that this connection is set for deletion.  By not
             * specifying "next;", we implicitly drop the packet after
             * updating conntrack state.  We would normally defer
             * ct_commit() to the "stateful" stage, but since we're
             * rejecting/dropping the packet, we go ahead and do it here.
             */
            var __match = "ct.est && ct_label.blocked == 0" in
            var actions = "ct_commit(ct_label=1/1); " in
            if (acl.action == "reject") {
                Reject(dpname, pipeline, stage, acl, __match, actions)
            } else {
                Flow(.logical_datapath = dpname,
                     .stage         = stage,
                     .priority         = acl.priority + oVN_ACL_PRI_OFFSET(),
                     .__match          = __match ++ " && (${acl.__match})",
                     .actions          = "${build_acl_log(acl)}/* drop */",
                     .external_ids     = stage_hint)
            }
        } else {
            /* There are no stateful ACLs in use on this datapath,
             * so a "reject/drop" ACL is simply the "reject/drop"
             * logical flow action in all cases. */
            if (acl.action == "reject") {
                Reject(dpname, pipeline, stage, acl, "", "")
            } else {
                Flow(.logical_datapath = dpname,
                     .stage         = stage,
                     .priority         = acl.priority + oVN_ACL_PRI_OFFSET(),
                     .__match          = acl.__match,
                     .actions          = "${build_acl_log(acl)}/* drop */",
                     .external_ids     = stage_hint)
            }
        }
    }
}

/* Add 34000 priority flow to allow DHCP reply from ovn-controller to all
 * logical ports of the datapath if the CMS has configured DHCPv4 options.
 * */
for (SwitchPortDHCPv4Options(.port = &SwitchPort{.lsp = lsp, .sw = &sw},
                             .dhcpv4_options = &nb.DHCP_Options{.options = options})) {
    (Some{var server_id}, Some{var server_mac}, Some{var lease_time}) =
        (map_get(options, "server_id"), map_get(options, "server_mac"), map_get(options, "lease_time")) in
    Flow(.logical_datapath = sw.dpname,
         .stage         = switch_stage(OUT, ACL),
         .priority         = 34000,
         .__match          = "outport == \"${lsp.name}\" && eth.src == ${server_mac} "
                             "&& ip4.src == ${server_id} && udp && udp.src == 67 "
                             "&& udp.dst == 68",
         .actions          = if (sw.has_stateful_acl) "ct_commit; next;" else "next;",
         .external_ids     = map_empty())
}

for (SwitchPortDHCPv6Options(.port = &SwitchPort{.lsp = lsp, .sw = &sw},
                             .dhcpv6_options = &nb.DHCP_Options{.options=options} )) {
    Some{var server_mac} = map_get(options, "server_id") in
    Some{var ea} = eth_addr_from_string(server_mac) in
    var server_ip = ipv6_string_mapped(in6_generate_lla(ea)) in
    /* Get the link local IP of the DHCPv6 server from the
     * server MAC. */
    Flow(.logical_datapath = sw.dpname,
         .stage         = switch_stage(OUT, ACL),
         .priority         = 34000,
         .__match          = "outport == \"${lsp.name}\" && eth.src == ${server_mac} "
                             "&& ip6.src == ${server_ip} && udp && udp.src == 547 "
                             "&& udp.dst == 546",
         .actions          = if (sw.has_stateful_acl) "ct_commit; next;" else "next;",
         .external_ids     = map_empty())
}

relation QoSAction(qos: uuid, key_action: string, value_action: integer)

QoSAction(qos, k, v) :-
    nb.QoS(._uuid = qos, .action = actions),
    var action = FlatMap(actions),
    (var k, var v) = action.

/* QoS rules */
for (&Switch(.dpname = dpname)) {
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(IN, QOS_MARK),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty());
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(OUT, QOS_MARK),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty());
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(IN, QOS_METER),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty());
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(OUT, QOS_METER),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty())
}

for (SwitchQoS(.sw = &sw, .qos = &qos)) {
    var ingress = if (qos.direction == "from-lport") true else false in
    var pipeline = if ingress "ingress" else "egress" in {
        var stage = if ingress switch_stage(IN, QOS_MARK) else switch_stage(OUT, QOS_MARK) in
        /* FIXME: Can value_action be negative? */
        for (QoSAction(qos._uuid, key_action, value_action)) {
            if (key_action == "dscp") {
                Flow(.logical_datapath = sw.dpname,
                     .stage         = stage,
                     .priority         = qos.priority,
                     .__match          = qos.__match,
                     .actions          = "ip.dscp = ${value_action}; next;",
                     .external_ids     = map_empty())
            }
        };

        (var burst: bit<64>, var rate: bit<64>) = {
            var rate: bit<64> = 0;
            var burst: bit<64> = 0;
            for (bw in qos.bandwidth) {
                /* FIXME: Can value_bandwidth be negative? */
                (var key_bandwidth, var value_bandwidth) = bw;
                if (key_bandwidth == "rate") {
                    rate = value_bandwidth
                } else if (key_bandwidth == "burst") {
                    burst = value_bandwidth
                } else ()
            };
            (burst, rate)
        } in
        if (rate != 0) {
            var stage = if (ingress) switch_stage(IN, QOS_METER) else switch_stage(OUT, QOS_METER) in
            var meter_action = if (burst != 0) {
                    "set_meter(${rate}, ${burst}); next;"
                } else {
                    "set_meter(${rate}); next;"
                } in
            /* Ingress and Egress QoS Meter Table.
             *
             * We limit the bandwidth of this flow by adding a meter table.
             */
            Flow(.logical_datapath = sw.dpname,
                 .stage         = stage,
                 .priority         = qos.priority,
                 .__match          = qos.__match,
                 .actions          = meter_action,
                 .external_ids     = map_empty())
        }
    }
}

/* LB rules */
for (&Switch(.ls = ls, .dpname = dpname)) {
    /* Ingress and Egress LB Table (Priority 0): Packets are allowed by
     * default.  */
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(IN, LB),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty());
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(OUT, LB),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty());

    if (not set_is_empty(ls.load_balancer)) {
        /* Ingress and Egress LB Table (Priority 65535).
         *
         * Send established traffic through conntrack for just NAT. */
        Flow(.logical_datapath = dpname,
             .stage         = switch_stage(IN, LB),
             .priority         = 65535,
             .__match          = "ct.est && !ct.rel && !ct.new && !ct.inv",
             .actions          = "${rEGBIT_CONNTRACK_NAT()} = 1; next;",
             .external_ids     = map_empty());
        Flow(.logical_datapath = dpname,
             .stage         = switch_stage(OUT, LB),
             .priority         = 65535,
             .__match          = "ct.est && !ct.rel && !ct.new && !ct.inv",
             .actions          = "${rEGBIT_CONNTRACK_NAT()} = 1; next;",
             .external_ids     = map_empty())
    }
}

/* stateful rules */
for (&Switch(.dpname = dpname)) {
    /* Ingress and Egress stateful Table (Priority 0): Packets are
     * allowed by default. */
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(IN, STATEFUL),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty());
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(OUT, STATEFUL),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty());

    /* If REGBIT_CONNTRACK_COMMIT is set as 1, then the packets should be
     * committed to conntrack. We always set ct_label.blocked to 0 here as
     * any packet that makes it this far is part of a connection we
     * want to allow to continue. */
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(IN, STATEFUL),
         .priority         = 100,
         .__match          = "${rEGBIT_CONNTRACK_COMMIT()} == 1",
         .actions          = "ct_commit(ct_label=0/1); next;",
         .external_ids     = map_empty());
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(OUT, STATEFUL),
         .priority         = 100,
         .__match          = "${rEGBIT_CONNTRACK_COMMIT()} == 1",
         .actions          = "ct_commit(ct_label=0/1); next;",
         .external_ids     = map_empty());

    /* If REGBIT_CONNTRACK_NAT is set as 1, then packets should just be sent
     * through nat (without committing).
     *
     * REGBIT_CONNTRACK_COMMIT is set for new connections and
     * REGBIT_CONNTRACK_NAT is set for established connections. So they
     * don't overlap.
     */
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(IN, STATEFUL),
         .priority         = 100,
         .__match          = "${rEGBIT_CONNTRACK_NAT()} == 1",
         .actions          = "ct_lb;",
         .external_ids     = map_empty());
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(OUT, STATEFUL),
         .priority         = 100,
         .__match          = "${rEGBIT_CONNTRACK_NAT()} == 1",
         .actions          = "ct_lb;",
         .external_ids     = map_empty())
}

/* Load balancing rules for new connections get committed to conntrack
 * table.  So even if REGBIT_CONNTRACK_COMMIT is set in a previous table
 * a higher priority rule for load balancing below also commits the
 * connection, so it is okay if we do not hit the above match on
 * REGBIT_CONNTRACK_COMMIT. */
for (SwitchLBVIP(.sw = &sw, .lb = &lb, .vip = (vip_key, vip_val))) {
    Some{(var ip_address, var port, var addr_family)} = ip_address_and_port_from_lb_key(vip_key) in

    /* New connections in Ingress table. */
    var __match = if (addr_family == aF_INET()) {
            "ct.new && ip4.dst == ${ip_address}"
        } else {
            "ct.new && ip6.dst == ${ip_address}"
        } in
    if (port != 0) {
        var __match2 = __match ++
            if (set_nth(lb.protocol, 0) == Some{"udp"}) {
                " && udp.dst == ${port}"
            } else {
                " && tcp.dst == ${port}"
            } in
        Flow(.logical_datapath = sw.dpname,
             .stage         = switch_stage(IN, STATEFUL),
             .priority         = 120,
             .__match          = __match2,
             .actions          = "ct_lb(${vip_val});",
             .external_ids     = map_empty())
    } else {
        Flow(.logical_datapath = sw.dpname,
             .stage         = switch_stage(IN, STATEFUL),
             .priority         = 110,
             .__match          = __match,
             .actions          = "ct_lb(${vip_val});",
             .external_ids     = map_empty())
    }
}


/* Logical switch ingress table 0: ingress port security - L2 (priority 50)
                  ingress table 1: ingress port security - IP (priority 90 and 80)
                  ingress table 2: ingress port security - ND (priority 90 and 80) */
for (&SwitchPort(.lsp = lsp, .sw = &sw, .json_name = json_name, .ps_eth_addresses = ps_eth_addresses)
     if is_enabled(lsp.enabled)) {
    for (pbinding in sb.OutProxy_Port_Binding(.logical_port = lsp.name)) {
        var __match = if (vec_is_empty(ps_eth_addresses)) {
                "inport == ${json_name}"
            } else {
                "inport == ${json_name} && eth.src == {${vec_space_sep(ps_eth_addresses)}}"
            } in
        var actions = match (map_get(pbinding.options, "qdisc_queue_id")) {
                None -> "next;",
                Some{id} -> "set_queue(${id}); next;"
            } in
        Flow(.logical_datapath = sw.dpname,
             .stage         = switch_stage(IN, PORT_SEC_L2),
             .priority         = 50,
             .__match          = __match,
             .actions          = actions,
             .external_ids     = map_empty())
    }
}

/**
* Build port security constraints on IPv4 and IPv6 src and dst fields
* and add logical flows to S_SWITCH_(IN/OUT)_PORT_SEC_IP stage.
*
* For each port security of the logical port, following
* logical flows are added
*   - If the port security has IPv4 addresses,
*     - Priority 90 flow to allow IPv4 packets for known IPv4 addresses
*
*   - If the port security has IPv6 addresses,
*     - Priority 90 flow to allow IPv6 packets for known IPv6 addresses
*
*   - If the port security has IPv4 addresses or IPv6 addresses or both
*     - Priority 80 flow to drop all IPv4 and IPv6 traffic
*/
for (SwitchPortPSAddresses(.port = &port@SwitchPort{.sw = &sw}, .ps_addrs = ps)
     if is_enabled(port.lsp.enabled) and
        (vec_len(ps.ipv4_addrs) > 64'd0 or vec_len(ps.ipv6_addrs) > 64'd0))
{
    if (vec_len(ps.ipv4_addrs) > 64'd0) {
        var dhcp_match = "inport == ${port.json_name}"
                         " && eth.src == ${ps.ea_s}"
                         " && ip4.src == 0.0.0.0"
                         " && ip4.dst == 255.255.255.255"
                         " && udp.src == 68 && udp.dst == 67" in {
            Flow(.logical_datapath = sw.dpname,
                 .stage         = switch_stage(IN, PORT_SEC_IP),
                 .priority         = 90,
                 .__match          = dhcp_match,
                 .actions          = "next;",
                 .external_ids     = map_empty())
        };
        var addrs = {
            var addrs: Vec<string> = vec_empty();
            for (addr in ps.ipv4_addrs) {
                /* When the netmask is applied, if the host portion is
                 * non-zero, the host can only use the specified
                 * address.  If zero, the host is allowed to use any
                 * address in the subnet.
                 */
                vec_push(addrs,
                         if (addr.plen == 32 or ((addr.addr & ~addr.mask) != 0)) {
                             addr.addr_s
                         } else {
                             /* host portion is zero */
                             "${addr.network_s}/${addr.plen}"
                         })
            };
            addrs
        } in
        var __match =
            "inport == ${port.json_name} && eth.src == ${ps.ea_s} && ip4.src == {" ++
            string_join(addrs, ", ") ++ "}" in
        {
            Flow(.logical_datapath = sw.dpname,
                 .stage         = switch_stage(IN, PORT_SEC_IP),
                 .priority         = 90,
                 .__match          = __match,
                 .actions          = "next;",
                 .external_ids     = map_empty())
        }
    };
    if (vec_len(ps.ipv6_addrs) > 64'd0) {
        var dad_match = "inport == ${port.json_name}"
                        " && eth.src == ${ps.ea_s}"
                        " && ip6.src == ::"
                        " && ip6.dst == ff02::/16"
                        " && icmp6.type == {131, 135, 143}" in
        {
            Flow(.logical_datapath = sw.dpname,
                 .stage         = switch_stage(IN, PORT_SEC_IP),
                 .priority         = 90,
                 .__match          = dad_match,
                 .actions          = "next;",
                 .external_ids     = map_empty())
        };
        var __match = "inport == ${port.json_name} && eth.src == ${ps.ea_s}" ++
                      build_port_security_ipv6_flow(IN, ps.ea, ps.ipv6_addrs) in
        {
            Flow(.logical_datapath = sw.dpname,
                 .stage         = switch_stage(IN, PORT_SEC_IP),
                 .priority         = 90,
                 .__match          = __match,
                 .actions          = "next;",
                 .external_ids     = map_empty())
        }
    };
    var __match = "inport == ${port.json_name} && eth.src == ${ps.ea_s} && ip" in
    {
        Flow(.logical_datapath = sw.dpname,
             .stage         = switch_stage(IN, PORT_SEC_IP),
             .priority         = 80,
             .__match          = __match,
             .actions          = "drop;",
             .external_ids     = map_empty())
    }
}

/**
 * Build port security constraints on ARP and IPv6 ND fields
 * and add logical flows to S_SWITCH_IN_PORT_SEC_ND stage.
 *
 * For each port security of the logical port, following
 * logical flows are added
 *   - If the port security has no IP (both IPv4 and IPv6) or
 *     if it has IPv4 address(es)
 *      - Priority 90 flow to allow ARP packets for known MAC addresses
 *        in the eth.src and arp.spa fields. If the port security
 *        has IPv4 addresses, allow known IPv4 addresses in the arp.tpa field.
 *
 *   - If the port security has no IP (both IPv4 and IPv6) or
 *     if it has IPv6 address(es)
 *     - Priority 90 flow to allow IPv6 ND packets for known MAC addresses
 *       in the eth.src and nd.sll/nd.tll fields. If the port security
 *       has IPv6 addresses, allow known IPv6 addresses in the nd.target field
 *       for IPv6 Neighbor Advertisement packet.
 *
 *   - Priority 80 flow to drop ARP and IPv6 ND packets.
 */
for (SwitchPortPSAddresses(.port = &port@SwitchPort{.sw = &sw}, .ps_addrs = ps)
     if is_enabled(port.lsp.enabled))
{
    var no_ip = vec_is_empty(ps.ipv4_addrs) and vec_is_empty(ps.ipv6_addrs) in
    {
        if (not vec_is_empty(ps.ipv4_addrs) or no_ip) {
            var __match: string = {
                var prefix = "inport == ${port.json_name} && eth.src == ${ps.ea_s} && arp.sha == ${ps.ea_s}";
                if (not vec_is_empty(ps.ipv4_addrs)) {
                    var spas: Vec<string> = vec_empty();
                    for (addr in ps.ipv4_addrs) {
                        /* When the netmask is applied, if the host portion is
                         * non-zero, the host can only use the specified
                         * address in the arp.spa.  If zero, the host is allowed
                         * to use any address in the subnet. */
                        if (addr.plen == 32 or (addr.addr & ~addr.mask) != 0) {
                            vec_push(spas, addr.addr_s)
                        } else {
                            vec_push(spas, "${addr.network_s}/${addr.plen}")
                        }
                    };
                    prefix ++ " && arp.spa == {${string_join(spas, \", \")}}"
                } else {
                    prefix
                }
            } in {
                Flow(.logical_datapath = sw.dpname,
                     .stage         = switch_stage(IN, PORT_SEC_ND),
                     .priority         = 90,
                     .__match          = __match,
                     .actions          = "next;",
                     .external_ids     = map_empty())
            }
        };
        if (not vec_is_empty(ps.ipv6_addrs) or no_ip) {
            var __match = "inport == ${port.json_name} && eth.src == ${ps.ea_s}" ++
                          build_port_security_ipv6_nd_flow(ps.ea, ps.ipv6_addrs) in
            {
                Flow(.logical_datapath = sw.dpname,
                     .stage         = switch_stage(IN, PORT_SEC_ND),
                     .priority         = 90,
                     .__match          = __match,
                     .actions          = "next;",
                     .external_ids     = map_empty())
            }
        };
        Flow(.logical_datapath = sw.dpname,
             .stage         = switch_stage(IN, PORT_SEC_ND),
             .priority         = 80,
             .__match          = "inport == ${port.json_name} && (arp || nd)",
             .actions          = "drop;",
             .external_ids     = map_empty())
    }
}

/* Ingress table 1 and 2: Port security - IP and ND, by default goto next.
 * (priority 0)*/
for (&Switch(.ls = ls, .dpname = dpname)) {
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(IN, PORT_SEC_ND),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty());
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(IN, PORT_SEC_IP),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty())
}

/* Ingress table 11: ARP/ND responder, skip requests coming from localnet
 * and vtep ports. (priority 100); see ovn-northd.8.xml for the
 * rationale. */
for (&SwitchPort(.lsp = lsp, .sw = &sw, .json_name = json_name)
     if is_enabled(lsp.enabled) and
        (lsp.__type == "localnet" or lsp.__type == "vtep"))
{
    Flow(.logical_datapath = sw.dpname,
         .stage         = switch_stage(IN, ARP_ND_RSP),
         .priority         = 100,
         .__match          = "inport == ${json_name}",
         .actions          = "next;",
         .external_ids     = map_empty())
}

function lsp_is_up(lsp: nb.Logical_Switch_Port): bool = {
    set_nth(lsp.up, 0) != Some{false}
}

/* Ingress table 11: ARP/ND responder, reply for known IPs.
 * (priority 50). */
/*
 * Add ARP/ND reply flows if either the
 *  - port is up or
 *  - port type is router or
 *  - port type is localport
 */
for (SwitchPortIPv4Address(.port = &SwitchPort{.lsp = lsp, .sw = &sw, .json_name = json_name},
                           .ea_s = ea_s, .addr = addr)
     if is_enabled(lsp.enabled) and
        (lsp_is_up(lsp) or lsp.__type == "router" or lsp.__type == "localport"))
{
    var __match = "arp.tpa == ${addr.addr_s} && arp.op == 1" in
    var actions = "eth.dst = eth.src; "
                  "eth.src = ${ea_s}; "
                  "arp.op = 2; /* ARP reply */ "
                  "arp.tha = arp.sha; "
                  "arp.sha = ${ea_s}; "
                  "arp.tpa = arp.spa; "
                  "arp.spa = ${addr.addr_s}; "
                  "outport = inport; "
                  "flags.loopback = 1; "
                  "output;" in
    {
        Flow(.logical_datapath = sw.dpname,
             .stage         = switch_stage(IN, ARP_ND_RSP),
             .priority         = 50,
             .__match          = __match,
             .actions          = actions,
             .external_ids     = map_empty());

        /* Do not reply to an ARP request from the port that owns the
         * address (otherwise a DHCP client that ARPs to check for a
         * duplicate address will fail).  Instead, forward it the usual
         * way.
         *
         * (Another alternative would be to simply drop the packet.  If
         * everything is working as it is configured, then this would
         * produce equivalent results, since no one should reply to the
         * request.  But ARPing for one's own IP address is intended to
         * detect situations where the network is not working as
         * configured, so dropping the request would frustrate that
         * intent.) */
        Flow(.logical_datapath = sw.dpname,
             .stage         = switch_stage(IN, ARP_ND_RSP),
             .priority         = 100,
             .__match          = __match ++ " && inport == ${json_name}",
             .actions          = "next;",
             .external_ids     = map_empty())
    }
}

/* For ND solicitations, we need to listen for both the
 * unicast IPv6 address and its all-nodes multicast address,
 * but always respond with the unicast IPv6 address. */
for (SwitchPortIPv6Address(.port = &SwitchPort{.lsp = lsp, .json_name = json_name, .sw = &sw},
                           .ea_s = ea_s, .addr = addr)
     if is_enabled(lsp.enabled) and
        (lsp_is_up(lsp) or lsp.__type == "router" or lsp.__type == "localport"))
{
    var __match = "nd_ns && ip6.dst == {${addr.addr_s}, ${addr.sn_addr_s}} && nd.target == ${addr.addr_s}" in
    var actions = "${if (lsp.__type == \"router\") \"nd_na_router\" else \"nd_na\"} { "
                  "eth.src = ${ea_s}; "
                  "ip6.src = ${addr.addr_s}; "
                  "nd.target = ${addr.addr_s}; "
                  "nd.tll = ${ea_s}; "
                  "outport = inport; "
                  "flags.loopback = 1; "
                  "output; "
                  "};" in
    {
        Flow(.logical_datapath = sw.dpname,
             .stage         = switch_stage(IN, ARP_ND_RSP),
             .priority         = 50,
             .__match          = __match,
             .actions          = actions,
             .external_ids     = map_empty());

        /* Do not reply to a solicitation from the port that owns the
         * address (otherwise DAD detection will fail). */
        Flow(.logical_datapath = sw.dpname,
             .stage         = switch_stage(IN, ARP_ND_RSP),
             .priority         = 100,
             .__match          = __match ++ " && inport == ${json_name}",
             .actions          = "next;",
             .external_ids     = map_empty())
    }
}

/* Ingress table 11: ARP/ND responder, by default goto next.
 * (priority 0)*/
for (ls in nb.Logical_Switch) {
    var lsname = uuid2name(ls._uuid) in {
        Flow(.logical_datapath = lsname,
             .stage         = switch_stage(IN, ARP_ND_RSP),
             .priority         = 0,
             .__match          = "1",
             .actions          = "next;",
             .external_ids     = map_empty())
    }
}

function build_dhcpv4_action(
    lsp_json_key: string,
    dhcpv4_options: nb.DHCP_Options,
    offer_ip: ovs_be32) : Option<(string, string, string)> =
{
    match (ip_parse_masked(dhcpv4_options.cidr)) {
        Left{err} -> {
            /* cidr defined is invalid */
            None
        },
        Right{(var host_ip, var mask)} -> {
            if (((offer_ip ^ host_ip) & mask) != 0) {
               /* the offer ip of the logical port doesn't belong to the cidr
                * defined in the DHCPv4 options.
                */
                None
            } else {
                match ((map_get(dhcpv4_options.options, "server_id"),
                        map_get(dhcpv4_options.options, "server_mac"),
                        map_get(dhcpv4_options.options, "lease_time")))
                {
                    (Some{var server_ip}, Some{var server_mac}, Some{var lease_time}) -> {
                        var options_map = dhcpv4_options.options;

                        /* server_mac is not DHCPv4 option, delete it from the smap. */
                        map_remove(options_map, "server_mac");
                        map_insert(options_map, "netmask", ip_fmt(mask));

                        /* We're not using SMAP_FOR_EACH because we want a consistent order of the
                         * options on different architectures (big or little endian, SSE4.2) */
                        var options: Vec<string> = vec_empty();
                        for (node in options_map) {
                            (var k, var v) = node;
                            vec_push(options, "${k} = ${v}")
                        };
                        var options_action = "${rEGBIT_DHCP_OPTS_RESULT()} = put_dhcp_opts(offerip = ${ip_fmt(offer_ip)}, " ++
                                             string_join(options, ", ") ++ "); next;";
                        var response_action = "eth.dst = eth.src; eth.src = ${server_mac}; "
                                              "ip4.dst = ${ip_fmt(offer_ip)}; ip4.src = ${server_ip}; udp.src = 67; "
                                              "udp.dst = 68; outport = inport; flags.loopback = 1; "
                                              "output;";

                        var ipv4_addr_match = "ip4.src == ${ip_fmt(offer_ip)} && ip4.dst == {${server_ip}, 255.255.255.255}";
                        Some{(options_action, response_action, ipv4_addr_match)}
                    },
                    _ -> {
                        /* "server_id", "server_mac" and "lease_time" should be
                         * present in the dhcp_options. */
                        //static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 5);
                        warn("Required DHCPv4 options not defined for lport - ${lsp_json_key}");
                        None
                    }
                }
            }
        }
    }
}

function build_dhcpv6_action(
    lsp_json_key: string,
    dhcpv6_options: nb.DHCP_Options,
    offer_ip: in6_addr): Option<(string, string)> =
{
    match (ipv6_parse_masked(dhcpv6_options.cidr)) {
        Left{err} -> {
            /* cidr defined is invalid */
            //warn("cidr is invalid - ${err}");
            None
        },
        Right{(var host_ip, var mask)} -> {
            var ip6_mask: in6_addr = ipv6_addr_bitxor(offer_ip, host_ip);
            ip6_mask = ipv6_addr_bitand(ip6_mask, mask);
            if (not ipv6_mask_is_any(ip6_mask)) {
                /* offer_ip doesn't belongs to the cidr defined in lport's DHCPv6
                 * options.*/
                //warn("ip does not belong to cidr");
                None
            } else {
                /* "server_id" should be the MAC address. */
                match (map_get(dhcpv6_options.options, "server_id")) {
                    None -> {
                        warn("server_id not present in the DHCPv6 options for lport ${lsp_json_key}");
                        None
                    },
                    Some{server_mac} -> {
                        match (eth_addr_from_string(server_mac)) {
                            None -> {
                                warn("server_id not present in the DHCPv6 options for lport ${lsp_json_key}");
                                None
                            },
                            Some{ea} -> {
                                /* Get the link local IP of the DHCPv6 server from the server MAC. */
                                var server_ip = ipv6_string_mapped(in6_generate_lla(ea));
                                var ia_addr = ipv6_string_mapped(offer_ip);
                                var options: Vec<string> = vec_empty();

                                /* Check whether the dhcpv6 options should be configured as stateful.
                                 * Only reply with ia_addr option for dhcpv6 stateful address mode. */
                                if (map_get_bool_def(dhcpv6_options.options, "dhcpv6_stateless", false) == false) {
                                    vec_push(options, "ia_addr = ${ia_addr}")
                                } else ();

                                /* We're not using SMAP_FOR_EACH because we want a consistent order of the
                                 * options on different architectures (big or little endian, SSE4.2) */
                                // FIXME: enumerate map in ascending order of keys. Is this good enough?
                                for (node in dhcpv6_options.options) {
                                    (var k, var v) = node;
                                    if (k != "dhcpv6_stateless") {
                                        vec_push(options, "${k} = ${v}")
                                    } else ()
                                };

                                var options_action = "${rEGBIT_DHCP_OPTS_RESULT()} = put_dhcpv6_opts(" ++
                                                     string_join(options, ", ")                         ++
                                                     "); next;";
                                var response_action = "eth.dst = eth.src; eth.src = ${server_mac}; "
                                                      "ip6.dst = ip6.src; ip6.src = ${server_ip}; udp.src = 547; "
                                                       "udp.dst = 546; outport = inport; flags.loopback = 1; "
                                                       "output;";
                                Some{(options_action, response_action)}
                            }
                        }
                    }
                }
            }
        }
    }
}


/* Logical switch ingress table 12 and 13: DHCP options and response
 * priority 100 flows. */
for (lsp in nb.Logical_Switch_Port
         /* Don't add the DHCP flows if the port is not enabled or if the
          * port is a router port. */
         if is_enabled(lsp.enabled) and lsp.__type != "router")
{
    for (lps in LogicalSwitchPort(.lport = lsp._uuid)) {
        var lsname = uuid2name(lps.lswitch) in
        var json_key = json_string_escape(lsp.name) in
        {
            /* DHCPv4 options enabled for this port */
            Some{var dhcpv4_options_uuid} = set_nth(lsp.dhcpv4_options, 0) in
            {
                for (dhcpv4_options in nb.DHCP_Options(._uuid = dhcpv4_options_uuid)) {
                    for (SwitchPortIPv4Address(.port = &SwitchPort{.lsp = nb.Logical_Switch_Port{._uuid = lsp._uuid}}, .ea_s = ea_s, .addr = addr)) {
                        Some{(var options_action, var response_action, var ipv4_addr_match)} =
                            build_dhcpv4_action(json_key, dhcpv4_options, addr.addr) in
                        {
                            var __match = "inport == ${json_key} && eth.src == ${ea_s} && "
                                          "ip4.src == 0.0.0.0 && ip4.dst == 255.255.255.255 && "
                                          "udp.src == 68 && udp.dst == 67" in
                            Flow(.logical_datapath = lsname,
                                 .stage         = switch_stage(IN, DHCP_OPTIONS),
                                 .priority         = 100,
                                 .__match          = __match,
                                 .actions          = options_action,
                                 .external_ids     = map_empty());

                            /* Allow ip4.src = OFFER_IP and
                             * ip4.dst = {SERVER_IP, 255.255.255.255} for the below
                             * cases
                             *  -  When the client wants to renew the IP by sending
                             *     the DHCPREQUEST to the server ip.
                             *  -  When the client wants to renew the IP by
                             *     broadcasting the DHCPREQUEST.
                             */
                            var __match = "inport == ${json_key} && eth.src == ${ea_s} && "
                                          "${ipv4_addr_match} && udp.src == 68 && udp.dst == 67" in
                            Flow(.logical_datapath = lsname,
                                 .stage         = switch_stage(IN, DHCP_OPTIONS),
                                 .priority         = 100,
                                 .__match          = __match,
                                 .actions          = options_action,
                                 .external_ids     = map_empty());

                            /* If REGBIT_DHCP_OPTS_RESULT is set, it means the
                             * put_dhcp_opts action  is successful. */
                            var __match = "inport == ${json_key} && eth.src == ${ea_s} && "
                                          "ip4 && udp.src == 68 && udp.dst == 67 && " ++
                                          rEGBIT_DHCP_OPTS_RESULT() in
                            Flow(.logical_datapath = lsname,
                                 .stage         = switch_stage(IN, DHCP_RESPONSE),
                                 .priority         = 100,
                                 .__match          = __match,
                                 .actions          = response_action,
                                 .external_ids     = map_empty())
                            // FIXME: is there a constraint somewhere that guarantees that build_dhcpv4_action
                            // returns Some() for at most 1 address in lsp_addrs? Otherwise, simulate this break
                            // by computing an aggregate that returns the first element of a group.
                            //break;
                        }
                    }
                }
            };

            /* DHCPv6 options enabled for this port */
            Some{var dhcpv6_options_uuid} = set_nth(lsp.dhcpv6_options, 0) in
            {
                for (dhcpv6_options in nb.DHCP_Options(._uuid = dhcpv6_options_uuid)) {
                    for (SwitchPortIPv6Address(.port = &SwitchPort{.lsp = nb.Logical_Switch_Port{._uuid = lsp._uuid}}, .ea_s = ea_s, .addr = addr)) {
                        Some{(var options_action, var response_action)} =
                            build_dhcpv6_action(json_key, dhcpv6_options, addr.addr) in
                        {
                            var __match = "inport == ${json_key} && eth.src == ${ea_s}"
                                          " && ip6.dst == ff02::1:2 && udp.src == 546 &&"
                                          " udp.dst == 547" in
                            {
                                Flow(.logical_datapath = lsname,
                                     .stage         = switch_stage(IN, DHCP_OPTIONS),
                                     .priority         = 100,
                                     .__match          = __match,
                                     .actions          = options_action,
                                     .external_ids     = map_empty());

                                /* If REGBIT_DHCP_OPTS_RESULT is set to 1, it means the
                                 * put_dhcpv6_opts action is successful */
                                Flow(.logical_datapath = lsname,
                                     .stage         = switch_stage(IN, DHCP_RESPONSE),
                                     .priority         = 100,
                                     .__match          = __match ++ " && ${rEGBIT_DHCP_OPTS_RESULT()}",
                                     .actions          = response_action,
                                     .external_ids     = map_empty())
                                // FIXME: is there a constraint somewhere that guarantees that build_dhcpv4_action
                                // returns Some() for at most 1 address in lsp_addrs? Otherwise, simulate this breaks
                                // by computing an aggregate that returns the first element of a group.
                                //break;
                            }
                        }
                    }
                }
            }
        }
    }
}

/* Logical switch ingress table 14 and 15: DNS lookup and response
 * priority 100 flows.
 */
for (LogicalSwitchHasDNSRecords(ls, true))
{
    var lsname = uuid2name(ls) in
    {
        Flow(.logical_datapath = lsname,
             .stage         = switch_stage(IN, DNS_LOOKUP),
             .priority         = 100,
             .__match          = "udp.dst == 53",
             .actions          = "${rEGBIT_DNS_LOOKUP_RESULT()} = dns_lookup(); next;",
             .external_ids     = map_empty());

        var action = "eth.dst <-> eth.src; ip4.src <-> ip4.dst; "
                     "udp.dst = udp.src; udp.src = 53; outport = inport; "
                     "flags.loopback = 1; output;" in
        Flow(.logical_datapath = lsname,
             .stage         = switch_stage(IN, DNS_RESPONSE),
             .priority         = 100,
             .__match          = "udp.dst == 53 && ${rEGBIT_DNS_LOOKUP_RESULT()}",
             .actions          = action,
             .external_ids     = map_empty());

        var action = "eth.dst <-> eth.src; ip6.src <-> ip6.dst; "
                     "udp.dst = udp.src; udp.src = 53; outport = inport; "
                     "flags.loopback = 1; output;" in
        Flow(.logical_datapath = lsname,
             .stage         = switch_stage(IN, DNS_RESPONSE),
             .priority         = 100,
             .__match          = "udp.dst == 53 && ${rEGBIT_DNS_LOOKUP_RESULT()}",
             .actions          = action,
             .external_ids     = map_empty())
    }
}

/* Ingress table 12 and 13: DHCP options and response, by default goto
 * next. (priority 0).
 * Ingress table 14 and 15: DNS lookup and response, by default goto next.
 * (priority 0).*/
for (ls in nb.Logical_Switch) {
    var lsname = uuid2name(ls._uuid) in {
        Flow(.logical_datapath = lsname,
             .stage         = switch_stage(IN, DHCP_OPTIONS),
             .priority         = 0,
             .__match          = "1",
             .actions          = "next;",
             .external_ids     = map_empty());

        Flow(.logical_datapath = lsname,
             .stage         = switch_stage(IN, DHCP_RESPONSE),
             .priority         = 0,
             .__match          = "1",
             .actions          = "next;",
             .external_ids     = map_empty());

        Flow(.logical_datapath = lsname,
             .stage         = switch_stage(IN, DNS_LOOKUP),
             .priority         = 0,
             .__match          = "1",
             .actions          = "next;",
             .external_ids     = map_empty());

        Flow(.logical_datapath = lsname,
             .stage         = switch_stage(IN, DNS_RESPONSE),
             .priority         = 0,
             .__match          = "1",
             .actions          = "next;",
             .external_ids     = map_empty())
    }
}

for (sw in &Switch(.dpname = dpname, .mcast_cfg = &mcast_cfg)
        if (mcast_cfg.enabled)) {
    for (SwitchMcastFloodRelayPorts(sw, relay_ports)) {
        for (SwitchMcastFloodReportPorts(sw, flood_report_ports)) {
            for (SwitchMcastFloodPorts(sw, flood_ports)) {
                var flood_relay = not set_is_empty(relay_ports) in
                var flood_reports = not set_is_empty(flood_report_ports) in
                var flood_static = not set_is_empty(flood_ports) in
                var igmp_act = {
                    if (flood_reports) {
                        (var mrouter_static, _) = mC_MROUTER_STATIC();
                        "clone { "
                            "outport = \"${mrouter_static}\"; "
                            "output; "
                        "}; igmp;"
                    } else {
                        "igmp;"
                    }
                } in {
                    /* Punt IGMP traffic to controller. */
                    Flow(.logical_datapath = dpname,
                         .stage            = switch_stage(IN, L2_LKUP),
                         .priority         = 100,
                         .__match          = "ip4 && ip.proto == 2",
                         .actions          = "${igmp_act}",
                         .external_ids     = map_empty());

                    /* Flood all IP multicast traffic destined to 224.0.0.X to
                     * all ports - RFC 4541, section 2.1.2, item 2.
                     */
                    (var flood, _) = mC_FLOOD() in
                    Flow(.logical_datapath = dpname,
                         .stage            = switch_stage(IN, L2_LKUP),
                         .priority         = 85,
                         .__match          = "ip4 && ip4.dst == 224.0.0.0/24",
                         .actions          = "outport = \"${flood}\"; output;",
                         .external_ids     = map_empty());

                    /* Forward uregistered IP multicast to routers with relay
                     * enabled and to any ports configured to flood IP
                     * multicast traffic. If configured to flood unregistered
                     * traffic this will be handled by the L2 multicast flow.
                     */
                    if (not mcast_cfg.flood_unreg) {
                        var relay_act = {
                            if (flood_relay) {
                                (var rtr_flood, _) = mC_MROUTER_FLOOD();
                                "clone { "
                                    "outport = \"${rtr_flood}\"; "
                                    "output; "
                                "}; "
                            } else {
                                ""
                            }
                        } in
                        var static_act = {
                            if (flood_static) {
                                (var mc_static, _) = mC_STATIC();
                                "outport =\"${mc_static}\"; output;"
                            } else {
                                ""
                            }
                        } in
                        var drop_act = {
                            if (not flood_relay and not flood_static) {
                                "drop;"
                            } else {
                                ""
                            }
                        } in
                        Flow(.logical_datapath = dpname,
                             .stage            = switch_stage(IN, L2_LKUP),
                             .priority         = 80,
                             .__match          = "ip4 && ip4.mcast",
                             .actions          =
                                "${relay_act}${static_act}${drop_act}",
                             .external_ids     = map_empty())
                    }
                }
            }
        }
    }
}

/* Ingress table 17: Add IP multicast flows learnt from IGMP (priority 90). */
for (IgmpSwitchMulticastGroup(.address = address, .switch = &sw)) {
    for (SwitchMcastFloodRelayPorts(&sw, relay_ports)) {
        for (SwitchMcastFloodPorts(&sw, flood_ports)) {
            var flood_relay = not set_is_empty(relay_ports) in
            var flood_static = not set_is_empty(flood_ports) in
            (var mc_rtr_flood, _) = mC_MROUTER_FLOOD() in
            (var mc_static, _) = mC_STATIC() in
            var relay_act = {
                if (flood_relay) {
                    "clone { "
                        "outport = \"${mc_rtr_flood}\"; output; "
                    "};"
                } else {
                    ""
                }
            } in
            var static_act = {
                if (flood_static) {
                    "clone { "
                        "outport =\"${mc_static}\"; "
                        "output; "
                    "};"
                } else {
                    ""
                }
            } in
            Flow(.logical_datapath = sw.dpname,
                 .stage            = switch_stage(IN, L2_LKUP),
                 .priority         = 90,
                 .__match          =
                    "eth.mcast && ip4 && ip4.dst == ${address}",
                 .actions          =
                    "${relay_act} ${static_act} outport = \"${address}\"; "
                    "output;",
                 .external_ids     = map_empty())
        }
    }
}

/* Ingress table 16: Destination lookup, broadcast and multicast handling
 * (priority 100). */
for (ls in nb.Logical_Switch) {
    var lsname = uuid2name(ls._uuid) in
    (var mc_flood, _) = mC_FLOOD() in
    Flow(.logical_datapath = lsname,
         .stage            = switch_stage(IN, L2_LKUP),
         .priority         = 70,
         .__match          = "eth.mcast",
         .actions          = "outport = \"${mc_flood}\"; output;",
         .external_ids     = map_empty())
}

/* Ingress table 16: Destination lookup, unicast handling (priority 50), */
for (SwitchPortStaticAddresses(.port = &SwitchPort{.json_name = json_name, .sw = &sw}, .addrs = addrs)) {
    Flow(.logical_datapath = sw.dpname,
         .stage         = switch_stage(IN, L2_LKUP),
         .priority         = 50,
         .__match          = "eth.dst == ${addrs.ea}",
         .actions          = "outport = ${json_name}; output;",
         .external_ids     = map_empty())
}

for (SwitchPortNewDynamicAddress(.port = &SwitchPort{.json_name = json_name, .sw = &sw},
                                 .address = Some{addrs})) {
    Flow(.logical_datapath = sw.dpname,
         .stage         = switch_stage(IN, L2_LKUP),
         .priority         = 50,
         .__match          = "eth.dst == ${addrs.ea}",
         .actions          = "outport = ${json_name}; output;",
         .external_ids     = map_empty())
}

for (&SwitchPort(.lsp = lsp,
                 .json_name = json_name,
                 .sw = &sw,
                 .peer = Some{&RouterPort{.lrp = lrp,
                                          .is_redirect = is_redirect,
                                          .router = &Router{.lr = lr,
                                                            .redirect_port_name = redirect_port_name}}})
     if (set_contains(lsp.addresses, "router")))
{
    Some{var mac} = scan_eth_addr(lrp.mac) in {
        var add_chassis_resident_check =
            sw.has_localnet_port and
            (/* The peer of this port represents a distributed
              * gateway port. The destination lookup flow for the
              * router's distributed gateway port MAC address should
              * only be programmed on the "redirect-chassis". */
             is_redirect or
             /* Check if the option 'reside-on-redirect-chassis'
              * is set to true on the peer port. If set to true
              * and if the logical switch has a localnet port, it
              * means the router pipeline for the packets from
              * this logical switch should be run on the chassis
              * hosting the gateway port.
              */
              map_get_bool_def(lrp.options, "reside-on-redirect-chassis", false)) in
        var __match = if (add_chassis_resident_check) {
            /* The destination lookup flow for the router's
             * distributed gateway port MAC address should only be
             * programmed on the "redirect-chassis". */
            "eth.dst == ${mac} && is_chassis_resident(${redirect_port_name})"
        } else {
            "eth.dst == ${mac}"
        } in
        Flow(.logical_datapath = sw.dpname,
             .stage         = switch_stage(IN, L2_LKUP),
             .priority         = 50,
             .__match          = __match,
             .actions          = "outport = ${json_name}; output;",
             .external_ids     = map_empty());

        /* Add ethernet addresses specified in NAT rules on
         * distributed logical routers. */
        if (is_redirect) {
            for (LogicalRouterNAT(.lr = lr._uuid, .nat = &nat)) {
                if (nat.__type == "dnat_and_snat") {
                    Some{var lport} = set_nth(nat.logical_port, 0) in
                    Some{var emac} = set_nth(nat.external_mac, 0) in
                    Some{var nat_mac} = eth_addr_from_string(emac) in
                    var __match = "eth.dst == ${nat_mac} && is_chassis_resident(\"${lport}\")" in
                    Flow(.logical_datapath = sw.dpname,
                         .stage         = switch_stage(IN, L2_LKUP),
                         .priority         = 50,
                         .__match          = __match,
                         .actions          = "outport = ${json_name}; output;",
                         .external_ids     = map_empty())
                }
            }
        }
    }
}
// FIXME: do we care about this?
/*        } else {
            static struct vlog_rate_limit rl = VLOG_RATE_LIMIT_INIT(1, 1);

            VLOG_INFO_RL(&rl,
                         "%s: invalid syntax '%s' in addresses column",
                         op->nbsp->name, op->nbsp->addresses[i]);
        }*/

/* Ingress table 16: Destination lookup for unknown MACs (priority 0). */
for (LogicalSwitchUnknownPorts(.ls = ls_uuid)) {
    var lsname = uuid2name(ls_uuid) in
    (var mc_unknown, _) = mC_UNKNOWN() in
    Flow(.logical_datapath = lsname,
         .stage            = switch_stage(IN, L2_LKUP),
         .priority         = 0,
         .__match          = "1",
         .actions          = "outport = \"${mc_unknown}\"; output;",
         .external_ids     = map_empty())
}

/* Egress tables 8: Egress port security - IP (priority 0)
 * Egress table 9: Egress port security L2 - multicast/broadcast (priority 100). */
for (&Switch(.dpname = dpname)) {
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(OUT, PORT_SEC_IP),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty());
    Flow(.logical_datapath = dpname,
         .stage         = switch_stage(OUT, PORT_SEC_L2),
         .priority         = 100,
         .__match          = "eth.mcast",
         .actions          = "output;",
         .external_ids     = map_empty())
}

/* Egress table 8: Egress port security - IP (priorities 90 and 80)
 * if port security enabled.
 *
 * Egress table 9: Egress port security - L2 (priorities 50 and 150).
 *
 * Priority 50 rules implement port security for enabled logical port.
 *
 * Priority 150 rules drop packets to disabled logical ports, so that they
 * don't even receive multicast or broadcast packets. */
for (&SwitchPort(.sw = &sw, .lsp = lsp, .json_name = json_name, .ps_eth_addresses = ps_eth_addresses)
     if is_enabled(lsp.enabled)) {
    var __match = if (vec_is_empty(ps_eth_addresses)) {
            "outport == ${json_name}"
        } else {
            "outport == ${json_name} && eth.dst == {${vec_space_sep(ps_eth_addresses)}}"
        } in
    Flow(.logical_datapath = sw.dpname,
         .stage         = switch_stage(OUT, PORT_SEC_L2),
         .priority         = 50,
         .__match          = __match,
         .actions          = "output;",
         .external_ids     = map_empty())
}

for (&SwitchPort(.lsp = lsp, .json_name = json_name, .sw = &sw) if not is_enabled(lsp.enabled)) {
    Flow(.logical_datapath = sw.dpname,
         .stage         = switch_stage(OUT, PORT_SEC_L2),
         .priority         = 150,
         .__match          = "outport == {$json_name}",
         .actions          = "drop;",
         .external_ids     = map_empty())
}

for (SwitchPortPSAddresses(.port = &SwitchPort{.json_name = json_name, .sw = &sw}, .ps_addrs = ps)
     if vec_len(ps.ipv4_addrs) > 64'd0 or vec_len(ps.ipv6_addrs) > 64'd0)
{
    if (vec_len(ps.ipv4_addrs) > 64'd0) {
        var addrs = {
            var addrs: Vec<string> = vec_empty();
            for (addr in ps.ipv4_addrs) {
                /* When the netmask is applied, if the host portion is
                 * non-zero, the host can only use the specified
                 * address.  If zero, the host is allowed to use any
                 * address in the subnet.
                 */
                vec_push(addrs,
                         if (addr.plen == 32 or ((addr.addr & ~addr.mask) != 0)) {
                             addr.addr_s ++
                                if (addr.plen != 32) { ", ${addr.bcast_s}" } else { "" }
                         } else {
                             /* host portion is zero */
                             "${addr.network_s}/${addr.plen}"
                         })
            };
            addrs
        } in
        var __match =
            "outport == ${json_name} && eth.dst == ${ps.ea_s} && ip4.dst == {255.255.255.255, 224.0.0.0/4, " ++
            string_join(addrs, ", ") ++ "}" in
        Flow(.logical_datapath = sw.dpname,
             .stage         = switch_stage(OUT, PORT_SEC_IP),
             .priority         = 90,
             .__match          = __match,
             .actions          = "next;",
             .external_ids     = map_empty())
    };
    if (vec_len(ps.ipv6_addrs) > 64'd0) {
        var __match = "outport == ${json_name} && eth.dst == ${ps.ea_s}" ++
                      build_port_security_ipv6_flow(OUT, ps.ea, ps.ipv6_addrs) in
        Flow(.logical_datapath = sw.dpname,
             .stage         = switch_stage(OUT, PORT_SEC_IP),
             .priority         = 90,
             .__match          = __match,
             .actions          = "next;",
             .external_ids     = map_empty())
    };
    var __match = "outport == ${json_name} && eth.dst == ${ps.ea_s} && ip" in
    Flow(.logical_datapath = sw.dpname,
         .stage         = switch_stage(OUT, PORT_SEC_IP),
         .priority         = 80,
         .__match          = __match,
         .actions          = "drop;",
         .external_ids     = map_empty())
}

/* Logical router ingress table 0: Admission control framework. */
for (&Router(.dpname = dpname)) {
    /* Logical VLANs not supported.
     * Broadcast/multicast source address is invalid. */
    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, ADMISSION),
         .priority         = 100,
         .__match          = "vlan.present || eth.src[40]",
         .actions          = "drop;",
         .external_ids     = map_empty())
}

/* Logical router ingress table 0: match (priority 50). */
for (&RouterPort(.lrp = lrp,
                 .json_name = json_name,
                 .networks = lrp_networks,
                 .router = &router,
                 .is_redirect = is_redirect)
     /* Drop packets from disabled logical ports (since logical flow
      * tables are default-drop). */
     if is_enabled(lrp.enabled))
{
    //if (op->derived) {
    //    /* No ingress packets should be received on a chassisredirect
    //     * port. */
    //    continue;
    //}

    Flow(.logical_datapath = router.dpname,
         .stage         = router_stage(IN, ADMISSION),
         .priority         = 50,
         .__match          = "eth.mcast && inport == ${json_name}",
         .actions          = "next;",
         .external_ids     = map_empty());

    var __match =
        "eth.dst == ${lrp_networks.ea_s} && inport == ${json_name}" ++
        if is_redirect {
            /* Traffic with eth.dst = l3dgw_port->lrp_networks.ea_s
             * should only be received on the "redirect-chassis". */
            " && is_chassis_resident(${json_string_escape(chassis_redirect_name(lrp.name))})"
        } else { "" } in
    Flow(.logical_datapath = router.dpname,
         .stage         = router_stage(IN, ADMISSION),
         .priority         = 50,
         .__match          = __match,
         .actions          = "next;",
         .external_ids     = map_empty())
}


/* Logical router ingress table 1: IP Input. */
for (&Router(.dpname = dpname, .mcast_cfg = &mcast_cfg)) {
    /* L3 admission control: drop multicast and broadcast source, localhost
     * source or destination, and zero network source or destination
     * (priority 100). */
    Flow(.logical_datapath = dpname,
         .stage            = router_stage(IN, IP_INPUT),
         .priority         = 100,
         .__match          = "ip4.src_mcast || "
         "ip4.src == 255.255.255.255 || "
         "ip4.src == 127.0.0.0/8 || "
         "ip4.dst == 127.0.0.0/8 || "
         "ip4.src == 0.0.0.0/8 || "
         "ip4.dst == 0.0.0.0/8",
         .actions          = "drop;",
         .external_ids     = map_empty());

    /* Allow multicast if relay enabled (priority 95). */
    var mcast_action = { if (mcast_cfg.relay) { "next;" } else { "drop;" } } in
    Flow(.logical_datapath = dpname,
         .stage            = router_stage(IN, IP_INPUT),
         .priority         = 95,
         .__match          = "ip4.mcast",
         .actions          = "${mcast_action}",
         .external_ids     = map_empty());

    /* ARP reply handling.  Use ARP replies to populate the logical
     * router's ARP table. */
    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, IP_INPUT),
         .priority         = 90,
         .__match          = "arp.op == 2",
         .actions          = "put_arp(inport, arp.spa, arp.sha);",
         .external_ids     = map_empty());

    /* Drop Ethernet local broadcast.  By definition this traffic should
     * not be forwarded.*/
    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, IP_INPUT),
         .priority         = 50,
         .__match          = "eth.bcast",
         .actions          = "drop;",
         .external_ids     = map_empty());

    /* TTL discard */
    Flow(
        .logical_datapath = dpname,
        .stage         = router_stage(IN, IP_INPUT),
        .priority         = 30,
        .__match          = "ip4 && ip.ttl == {0, 1}",
        .actions          = "drop;",
        .external_ids     = map_empty());

    /* ND advertisement handling.  Use advertisements to populate
     * the logical router's ARP/ND table. */
    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, IP_INPUT),
         .priority         = 90,
         .__match          = "nd_na",
         .actions          = "put_nd(inport, nd.target, nd.tll);",
         .external_ids     = map_empty());

    /* Lean from neighbor solicitations that were not directed at
     * us.  (A priority-90 flow will respond to requests to us and
     * learn the sender's mac address. */
    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, IP_INPUT),
         .priority         = 80,
         .__match          = "nd_ns",
         .actions          = "put_nd(inport, ip6.src, nd.sll);",
         .external_ids     = map_empty());

    /* Pass other traffic not already handled to the next table for
     * routing. */
    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, IP_INPUT),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty())
}

function format_v4_networks(networks: lport_addresses, add_bcast: bool): string =
{
    var addrs: Vec<string> = vec_empty();
    for (addr in networks.ipv4_addrs) {
        vec_push(addrs, addr.addr_s);
        if (add_bcast) {
            vec_push(addrs, addr.bcast_s)
        } else ()
    };
    if (vec_len(addrs) == 64'd1) {
        string_join(addrs , ", ")
    } else {
        "{" ++ string_join(addrs , ", ") ++ "}"
    }
}

function format_v6_networks(networks: lport_addresses): string =
{
    var addrs: Vec<string> = vec_empty();
    for (addr in networks.ipv6_addrs) {
        vec_push(addrs, addr.addr_s)
    };
    if (vec_len(addrs) == 64'd1) {
        string_join(addrs , ", ")
    } else {
        "{" ++ string_join(addrs , ", ") ++ "}"
    }
}

/* The following relation is used in ARP reply flow generation to determine whether
 * the is_chassis_resident check must be added to the flow.
 */
relation AddChassisResidentCheck_(lrp: uuid, add_check: bool)

AddChassisResidentCheck_(lrp._uuid, res) :-
    &SwitchPort(.peer = Some{&RouterPort{.lrp = lrp, .router = &router, .is_redirect = is_redirect}},
                .sw = &Switch{.has_localnet_port = true}),
    is_some(router.l3dgw_port),
    var res = if (is_redirect) {
        /* Traffic with eth.src = l3dgw_port->lrp_networks.ea_s
         * should only be sent from the "redirect-chassis", so that
         * upstream MAC learning points to the "redirect-chassis".
         * Also need to avoid generation of multiple ARP responses
         * from different chassis. */
        true
    } else {
        /* Check if the option 'reside-on-redirect-chassis'
         * is set to true on the router port. If set to true
         * and if peer's logical switch has a localnet port, it
         * means the router pipeline for the packets from
         * peer's logical switch is be run on the chassis
         * hosting the gateway port and it should reply to the
         * ARP requests for the router port IPs.
         */
        map_get_bool_def(lrp.options, "reside-on-redirect-chassis", false)
    }.


relation AddChassisResidentCheck(lrp: uuid, add_check: bool)

AddChassisResidentCheck(lrp, add_check) :-
    AddChassisResidentCheck_(lrp, add_check).

AddChassisResidentCheck(lrp, false) :-
    nb.Logical_Router_Port(._uuid = lrp),
    not AddChassisResidentCheck_(lrp, _).


function get_force_snat_ip(lr: nb.Logical_Router, key_type: string): Option<(string, ovs_be32)> =
{
    match (map_get(lr.options, key_type ++ "_force_snat_ip")) {
        None -> None,
        Some{ip_address} -> {
            match (ip_parse_masked(ip_address)) {
                Left{err} -> {
                    warn("bad ip ${ip_address} in options of router ${uuid2str(lr._uuid)}");
                    None
                },
                Right{(ip, mask)} -> {
                    if (mask != 32'hffffffff) {
                        warn("bad ip ${ip_address} in options of router ${uuid2str(lr._uuid)}");
                        None
                    } else {
                        Some{(ip_address, ip)}
                    }
                }
            }
        }
    }
}

/* Logical router ingress table 1: IP Input for IPv4. */
for (&RouterPort(.router = &router, .networks = networks)
     if (not vec_is_empty(networks.ipv4_addrs)))
{
    /* L3 admission control: drop packets that originate from an
     * IPv4 address owned by the router or a broadcast address
     * known to the router (priority 100). */
    var __match = "ip4.src == "                                  ++
                   format_v4_networks(networks, true)            ++
                   " && ${rEGBIT_EGRESS_LOOPBACK()} == 0" in
    Flow(.logical_datapath = router.dpname,
         .stage         = router_stage(IN, IP_INPUT),
         .priority         = 100,
         .__match          = __match,
         .actions          = "drop;",
         .external_ids     = map_empty());

    /* ICMP echo reply.  These flows reply to ICMP echo requests
     * received for the router's IP address. Since packets only
     * get here as part of the logical router datapath, the inport
     * (i.e. the incoming locally attached net) does not matter.
     * The ip.ttl also does not matter (RFC1812 section 4.2.2.9) */
    var __match = "ip4.dst == "                                  ++
                  format_v4_networks(networks, false)            ++
                  " && icmp4.type == 8 && icmp4.code == 0" in
    Flow(.logical_datapath = router.dpname,
         .stage         = router_stage(IN, IP_INPUT),
         .priority         = 90,
         .__match          = __match,
         .actions          = "ip4.dst <-> ip4.src; "
                             "ip.ttl = 255; "
                             "icmp4.type = 0; "
                             "flags.loopback = 1; "
                             "next; ",
         .external_ids     = map_empty())
}

/* ICMP time exceeded */
for (RouterPortNetworksIPv4Addr(.port = &RouterPort{.lrp = lrp,
                                                    .json_name = json_name,
                                                    .router = &router,
                                                    .networks = networks,
                                                    .is_redirect = is_redirect},
                                .addr = addr))
{
    Flow(.logical_datapath = router.dpname,
         .stage         = router_stage(IN, IP_INPUT),
         .priority         = 40,
         .__match          = "inport == ${json_name} && ip4 && "
                             "ip.ttl == {0, 1} && !ip.later_frag",
         .actions          = "icmp4 {"
                             "eth.dst <-> eth.src; "
                             "icmp4.type = 11; /* Time exceeded */ "
                             "icmp4.code = 0; /* TTL exceeded in transit */ "
                             "ip4.dst = ip4.src; "
                             "ip4.src = ${addr.addr_s}; "
                             "ip.ttl = 255; "
                             "next; };",
         .external_ids     = map_empty());

    /* ARP reply.  These flows reply to ARP requests for the router's own
     * IP address. */
    for (AddChassisResidentCheck(lrp._uuid, add_chassis_resident_check)) {
        var __match =
            "inport == ${json_name} && arp.spa == ${addr.network_s}/${addr.plen} "
            "&& arp.tpa == ${addr.addr_s}"
            " && arp.op == 1" ++
            if (add_chassis_resident_check) {
                " && is_chassis_resident(${router.redirect_port_name})"
            } else "" in
        var actions =
            "put_arp(inport, arp.spa, arp.sha); "
            "eth.dst = eth.src; "
            "eth.src = ${networks.ea_s}; "
            "arp.op = 2; /* ARP reply */ "
            "arp.tha = arp.sha; "
            "arp.sha = ${networks.ea_s}; "
            "arp.tpa = arp.spa; "
            "arp.spa = ${addr.addr_s}; "
            "outport = ${json_name}; "
            "flags.loopback = 1; "
            "output;" in
        Flow(.logical_datapath = router.dpname,
             .stage         = router_stage(IN, IP_INPUT),
             .priority         = 90,
             .__match          = __match,
             .actions          = actions,
             .external_ids     = map_empty())
    };

    /* Learn from ARP requests that were not directed at us. A typical
     * use case is GARP request handling.  (A priority-90 flow will
     * respond to request to us and learn the sender's mac address.) */
    var __match =
        "inport == ${json_name} && arp.spa == ${addr.network_s}/${addr.plen}"
        " && arp.op == 1" ++
        if is_redirect " && is_chassis_resident(${json_string_escape(chassis_redirect_name(lrp.name))})" else "" in
    Flow(.logical_datapath = router.dpname,
         .stage         = router_stage(IN, IP_INPUT),
         .priority         = 80,
         .__match          = __match,
         .actions          = "put_arp(inport, arp.spa, arp.sha);",
         .external_ids     = map_empty())
}

for (&RouterPort(.lrp = lrp,
                 .router = &Router{.lr = lr, .dpname = dpname},
                 .json_name = json_name,
                 .networks = networks,
                 .is_redirect = is_redirect))
{
    for (RouterLBVIP(.router = &Router{.lr = nb.Logical_Router{._uuid= lr._uuid}}, .vip = (vip_key, _))) {
        Some{(var ip_address, _, var addr_family)} = ip_address_and_port_from_lb_key(vip_key) in
        var __match = if (addr_family == aF_INET()) {
               "inport == ${json_name} && arp.tpa == ${ip_address} && arp.op == 1"
            } else {
               "inport == ${json_name} && nd_ns && nd.target == ${ip_address}"
            } in
        var actions = if (addr_family == aF_INET()) {
            "eth.dst = eth.src; "
            "eth.src = ${networks.ea_s}; "
            "arp.op = 2; /* ARP reply */ "
            "arp.tha = arp.sha; "
            "arp.sha = ${networks.ea_s}; "
            "arp.tpa = arp.spa; "
            "arp.spa = ${ip_address}; "
            "outport = ${json_name}; "
            "flags.loopback = 1; "
            "output;"
        } else {
            "nd_na { "
            "eth.src = ${networks.ea_s}; "
            "ip6.src = ${ip_address}; "
            "nd.target = ${ip_address}; "
            "nd.tll = ${networks.ea_s}; "
            "outport = inport; "
            "flags.loopback = 1; "
            "output; "
            "};"
        } in
        Flow(.logical_datapath = dpname,
             .stage         = router_stage(IN, IP_INPUT),
             .priority         = 90,
             .__match          = __match,
             .actions          = actions,
             .external_ids     = map_empty())
    };

    for (LogicalRouterNAT(lr._uuid, &nat) if nat.__type != "snat") {
        Some{var ip} = match (ip_parse(nat.external_ip)) {
            Some{ip} -> { Some{ip} },
            None -> {
                warn("bad ip address ${nat.external_ip} in nat configuration "
                     "for router ${uuid2str(lr._uuid)}");
                None: Option<ovs_be32>
            }
        } in
        /* ARP handling for external IP addresses.
         *
         * DNAT IP addresses are external IP addresses that need ARP
         * handling. */
        var __match = "inport == ${json_name} && arp.tpa == ${ip_fmt(ip)} && arp.op == 1" in
        var actions = "eth.dst = eth.src; "
                      "arp.op = 2; /* ARP reply */ "
                      "arp.tha = arp.sha; " in
        (var __match2, var actions2) = if is_redirect {
            match ((set_nth(nat.external_mac, 0), set_nth(nat.logical_port, 0))) {
                (Some{external_mac}, Some{logical_port}) -> {
                    match (eth_addr_from_string(external_mac)) {
                        Some{mac} -> {
                            /* distributed NAT case, use nat->external_mac */
                            /* Traffic with eth.src = nat->external_mac should only be
                             * sent from the chassis where nat->logical_port is
                             * resident, so that upstream MAC learning points to the
                             * correct chassis.  Also need to avoid generation of
                             * multiple ARP responses from different chassis. */
                            ( __match ++ " && is_chassis_resident(\"${logical_port}\")"
                            , actions ++ "eth.src = ${mac}; arp.sha = ${mac}; ")
                        },
                        None -> {
                            ( __match ++ " && is_chassis_resident(${json_string_escape(chassis_redirect_name(lrp.name))})"
                            , actions ++ "eth.src = ${networks.ea_s}; arp.sha = ${networks.ea_s}; ")
                        }
                    }
                },
                _ -> {
                    /* Traffic with eth.src = l3dgw_port->lrp_networks.ea_s
                     * should only be sent from the "redirect-chassis", so that
                     * upstream MAC learning points to the "redirect-chassis".
                     * Also need to avoid generation of multiple ARP responses
                     * from different chassis. */
                    ( __match ++ " && is_chassis_resident(${json_string_escape(chassis_redirect_name(lrp.name))})"
                    , actions ++ "eth.src = ${networks.ea_s}; arp.sha = ${networks.ea_s}; ")
                }
            }
        } else {
            ( __match
            , actions ++ "eth.src = ${networks.ea_s}; arp.sha = ${networks.ea_s}; ")
        } in
        Flow(.logical_datapath = dpname,
             .stage         = router_stage(IN, IP_INPUT),
             .priority         = 90,
             .__match          = __match2,
             .actions          = actions2                    ++
                                "arp.tpa = arp.spa; "
                                "arp.spa = ${ip_fmt(ip)}; "
                                "outport = ${json_name}; "
                                "flags.loopback = 1; "
                                "output;",
             .external_ids     = map_empty())
    }
}

for (RouterPortNetworksIPv4Addr(.port = &RouterPort{.router = &Router{.dpname = dpname,
                                                                      .l3dgw_port = None,
                                                                      .is_gateway = false}},
                                .addr = addr))
{
    /* UDP/TCP port unreachable. */
    var __match = "ip4 && ip4.dst == ${addr.addr_s} && !ip.later_frag && udp" in
    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, IP_INPUT),
         .priority         = 80,
         .__match          = __match,
         .actions          = "icmp4 {"
                             "eth.dst <-> eth.src; "
                             "ip4.dst <-> ip4.src; "
                             "ip.ttl = 255; "
                             "icmp4.type = 3; "
                             "icmp4.code = 3; "
                             "next; };",
         .external_ids     = map_empty());

    var __match = "ip4 && ip4.dst == ${addr.addr_s} && !ip.later_frag && tcp" in
    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, IP_INPUT),
         .priority         = 80,
         .__match          = __match,
         .actions          = "tcp_reset {"
                             "eth.dst <-> eth.src; "
                             "ip4.dst <-> ip4.src; "
                             "next; };",
         .external_ids     = map_empty());

    var __match = "ip4 && ip4.dst == ${addr.addr_s} && !ip.later_frag" in
    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, IP_INPUT),
         .priority         = 70,
         .__match          = __match,
         .actions          = "icmp4 {"
                             "eth.dst <-> eth.src; "
                             "ip4.dst <-> ip4.src; "
                             "ip.ttl = 255; "
                             "icmp4.type = 3; "
                             "icmp4.code = 2; "
                             "next; };",
         .external_ids     = map_empty())
}


for (&RouterPort(.lrp = lrp,
                 .router = &Router{.lr = lr, .dpname = dpname, .nats = nats},
                 .json_name = json_name,
                 .networks = networks))
{
    /* A gateway router can have 2 SNAT IP addresses to force DNATed and
     * LBed traffic respectively to be SNATed.  In addition, there can be
     * a number of SNAT rules in the NAT table. */
    var snat_ips: Set<ovs_be32> = {
        var snat_ips: Set<ovs_be32> = set_empty();
        for (nat in nats) {
            if (deref(nat).__type == "snat") {
                var ip = deref(nat).external_ip;
                match (ip_parse(ip)) {
                    Some{snat_ip} -> set_insert(snat_ips, snat_ip),
                    None -> warn("bad ip address ${ip} in nat configuration "
                                 "for router ${uuid2str(lr._uuid)}")
                }
            } else ()
        };
        match (get_force_snat_ip(lr, "dnat")) {
            Some{(_, snat_ip)} -> set_insert(snat_ips, snat_ip),
            None -> ()
        };
        match (get_force_snat_ip(lr, "lb")) {
            Some{(_, snat_ip)} -> set_insert(snat_ips, snat_ip),
            None -> ()
        };
        snat_ips
    } in
    var ips = {
        var ips: Vec<string> = vec_empty();
        for (ip in networks.ipv4_addrs) {
            if (not set_contains(snat_ips, ip.addr)) {
                vec_push(ips, ip.addr_s)
            } else ()
        };
        ips
    } in
    var __match = "ip4.dst == {" ++ string_join(ips, ", ") ++ "}" in
    if (not vec_is_empty(ips)) {
        Flow(.logical_datapath = dpname,
             .stage         = router_stage(IN, IP_INPUT),
             .priority         = 60,
             .__match          = __match,
             .actions          = "drop;",
             .external_ids     = map_empty())
    }
}

/* Logical router ingress table 1: IP Input for IPv6. */
for (&RouterPort(.router = &router, .networks = networks)
     if (not vec_is_empty(networks.ipv6_addrs)))
{
    //if (op->derived) {
    //    /* No ingress packets are accepted on a chassisredirect
    //     * port, so no need to program flows for that port. */
    //    continue;
    //}
    /* L3 admission control: drop packets that originate from an
     * IPv6 address owned by the router (priority 100). */
    var __match = "ip6.src == " ++
                   format_v6_networks(networks) in
    Flow(.logical_datapath = router.dpname,
         .stage         = router_stage(IN, IP_INPUT),
         .priority         = 100,
         .__match          = __match,
         .actions          = "drop;",
         .external_ids     = map_empty());

    /* ICMPv6 echo reply.  These flows reply to echo requests
     * received for the router's IP address. */
    var __match = "ip6.dst == "                   ++
                  format_v6_networks(networks)    ++
                  " && icmp6.type == 128 && icmp6.code == 0" in
    Flow(.logical_datapath = router.dpname,
         .stage         = router_stage(IN, IP_INPUT),
         .priority         = 90,
         .__match          = __match,
         .actions          = "ip6.dst <-> ip6.src; "
         "ip.ttl = 255; "
         "icmp6.type = 129; "
         "flags.loopback = 1; "
         "next; ",
         .external_ids     = map_empty());

    /* Drop IPv6 traffic to this router. */
    var __match = "ip6.dst == " ++
                  format_v6_networks(networks) in
    Flow(.logical_datapath = router.dpname,
         .stage         = router_stage(IN, IP_INPUT),
         .priority         = 60,
         .__match          = __match,
         .actions          = "drop;",
         .external_ids     = map_empty())
}

/* ND reply.  These flows reply to ND solicitations for the
 * router's own IP address. */
for (RouterPortNetworksIPv6Addr(.port = &RouterPort{.lrp = lrp,
                                                    .is_redirect = is_redirect,
                                                    .router = &router,
                                                    .networks = networks,
                                                    .json_name = json_name},
                                .addr = addr))
{
    var __match =
        "inport == ${json_name} && nd_ns && ip6.dst == {${addr.addr_s}, ${addr.sn_addr_s}} "
        "&& nd.target == ${addr.addr_s}" ++
        if (is_redirect) {
            /* Traffic with eth.src = l3dgw_port->lrp_networks.ea_s
             * should only be sent from the "redirect-chassis", so that
             * upstream MAC learning points to the "redirect-chassis".
             * Also need to avoid generation of multiple ND replies
             * from different chassis. */
            " && is_chassis_resident(${json_string_escape(chassis_redirect_name(lrp.name))})"
        } else { "" } in
    var actions = "put_nd(inport, ip6.src, nd.sll); "
                  "nd_na_router { "
                  "eth.src = ${networks.ea_s}; "
                  "ip6.src = ${addr.addr_s}; "
                  "nd.target = ${addr.addr_s}; "
                  "nd.tll = ${networks.ea_s}; "
                  "outport = inport; "
                  "flags.loopback = 1; "
                  "output; "
                  "};" in
    Flow(.logical_datapath = router.dpname,
         .stage         = router_stage(IN, IP_INPUT),
         .priority         = 90,
         .__match          = __match,
         .actions          = actions,
         .external_ids     = map_empty())
}

/* UDP/TCP port unreachable */
for (RouterPortNetworksIPv6Addr(.port = &RouterPort{.router = &Router{.dpname = dpname,
                                                                      .l3dgw_port = None,
                                                                      .is_gateway = false},
                                                    .json_name = json_name},
                                .addr = addr))
{
    var __match = "ip6 && ip6.dst == ${addr.addr_s} && !ip.later_frag && tcp" in
    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, IP_INPUT),
         .priority         = 80,
         .__match          = __match,
         .actions          = "tcp_reset {"
                             "eth.dst <-> eth.src; "
                             "ip6.dst <-> ip6.src; "
                             "next; };",
         .external_ids     = map_empty());

    var __match = "ip6 && ip6.dst == ${addr.addr_s} && !ip.later_frag && udp" in
    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, IP_INPUT),
         .priority         = 80,
         .__match          = __match,
         .actions          = "icmp6 {"
                             "eth.dst <-> eth.src; "
                             "ip6.dst <-> ip6.src; "
                             "ip.ttl = 255; "
                             "icmp6.type = 1; "
                             "icmp6.code = 4; "
                             "next; };",
         .external_ids     = map_empty());

    var __match = "ip6 && ip6.dst == ${addr.addr_s} && !ip.later_frag" in
    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, IP_INPUT),
         .priority         = 70,
         .__match          = __match,
         .actions          = "icmp6 {"
                             "eth.dst <-> eth.src; "
                             "ip6.dst <-> ip6.src; "
                             "ip.ttl = 255; "
                             "icmp6.type = 1; "
                             "icmp6.code = 3; "
                             "next; };",
         .external_ids     = map_empty())
}

/* ICMPv6 time exceeded */
for (RouterPortNetworksIPv6Addr(.port = &RouterPort{.router = &router,
                                                    .json_name = json_name},
                                .addr = addr)
     /* skip link-local address */
     if (not in6_is_lla(addr.network)))
{
    var __match = "inport == ${json_name} && ip6 && "
                  "ip6.src == ${addr.network_s}/${addr.plen} && "
                  "ip.ttl == {0, 1} && !ip.later_frag" in
    var actions = "icmp6 {"
                  "eth.dst <-> eth.src; "
                  "ip6.dst = ip6.src; "
                  "ip6.src = ${addr.addr_s}; "
                  "ip.ttl = 255; "
                  "icmp6.type = 3; /* Time exceeded */ "
                  "icmp6.code = 0; /* TTL exceeded in transit */ "
                  "next; };" in
    Flow(.logical_datapath = router.dpname,
         .stage         = router_stage(IN, IP_INPUT),
         .priority         = 40,
         .__match          = __match,
         .actions          = actions,
         .external_ids     = map_empty())
}

/* NAT, Defrag and load balancing. */

for (&Router(.lr = lr, .dpname = dpname)) {
    /* Packets are allowed by default. */
    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, DEFRAG),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty());

    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, UNSNAT),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty());

    Flow(.logical_datapath = dpname,
         .stage         = router_stage(OUT, SNAT),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty());

    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, DNAT),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty());

    Flow(.logical_datapath = dpname,
         .stage         = router_stage(OUT, UNDNAT),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty());

    Flow(.logical_datapath = dpname,
         .stage         = router_stage(OUT, EGR_LOOP),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty())
}

/* NAT rules are only valid on Gateway routers and routers with
 * l3dgw_port (router has a port with "redirect-chassis"
 * specified). */
for (&Router(.dpname = dpname,
             .lr = lr,
             .l3dgw_port = l3dgw_port,
             .redirect_port_name = redirect_port_name,
             .is_gateway = is_gateway)
     if is_some(l3dgw_port) or is_gateway)
{
    for (LogicalRouterNAT(.lr = lr._uuid, .nat = &nat)) {
        true == match (ip_parse_masked(nat.external_ip)) {
            Left{err} -> {
                warn("bad external ip ${nat.external_ip} for nat");
                false
            },
            Right{(_, mask)} -> {
                if (mask != 32'hffffffff) {
                    warn("bad external ip ${nat.external_ip} for nat");
                    false
                } else { true }
            }
        } in
        /* Check the validity of nat->logical_ip. 'logical_ip' can
         * be a subnet when the type is "snat". */
        (var mask, true) = match ((ip_parse_masked(nat.logical_ip), nat.__type)) {
            (Left{err}, "snat") -> {
                warn("bad ip network or ip ${nat.logical_ip} for snat in router ${uuid2str(lr._uuid)}");
                (32'd0, false)
            },
            (Right{(_, mask)}, "snat") -> (mask, true),
            (Left{err}, _) -> {
                warn("bad ip ${nat.logical_ip} for dnat in router ${uuid2str(lr._uuid)}");
                (32'd0, false)
            },
            (Right{(_, mask)}, _) -> {
                if (mask != 32'hffffffff) {
                    warn("bad ip ${nat.logical_ip} for dnat in router ${uuid2str(lr._uuid)}");
                    (32'd0, false)
                } else { (mask, true) }
            }
        } in
        /* For distributed router NAT, determine whether this NAT rule
         * satisfies the conditions for distributed NAT processing. */
        Some{var mac: Option<eth_addr>} =
            if (is_some(l3dgw_port) and nat.__type == "dnat_and_snat") {
                match ((set_nth(nat.logical_port, 0), set_nth(nat.external_mac, 0))) {
                    (Some{_}, Some{external_mac}) -> {
                        match (eth_addr_from_string(external_mac)) {
                            Some{mac} -> Some { Some{mac} },
                            None -> {
                                warn("bad mac ${external_mac} for dnat in router ${uuid2str(lr._uuid)}");
                                None
                            }
                        }
                    },
                    _ -> { Some{ None } }
                }
            } else { Some{ None } } in
        {
            /* Ingress UNSNAT table: It is for already established connections'
             * reverse traffic. i.e., SNAT has already been done in egress
             * pipeline and now the packet has entered the ingress pipeline as
             * part of a reply. We undo the SNAT here.
             *
             * Undoing SNAT has to happen before DNAT processing.  This is
             * because when the packet was DNATed in ingress pipeline, it did
             * not know about the possibility of eventual additional SNAT in
             * egress pipeline. */
            if (nat.__type == "snat" or nat.__type == "dnat_and_snat") {
                if (l3dgw_port == None) {
                    /* Gateway router. */
                    Flow(.logical_datapath = dpname,
                         .stage         = router_stage(IN, UNSNAT),
                         .priority         = 90,
                         .__match          = "ip && ip4.dst == ${nat.external_ip}",
                         .actions          = "ct_snat;",
                         .external_ids     = map_empty())
                };
                Some{var gwport} = l3dgw_port in {
                    /* Distributed router. */

                    /* Traffic received on l3dgw_port is subject to NAT. */
                    var __match =
                        "ip && ip4.dst == ${nat.external_ip}"
                        " && inport == ${json_string_escape(gwport.name)}" ++
                        if (mac == None) {
                            /* Flows for NAT rules that are centralized are only
                             * programmed on the "redirect-chassis". */
                            " && is_chassis_resident(${redirect_port_name})"
                        } else { "" } in
                    Flow(.logical_datapath = dpname,
                         .stage         = router_stage(IN, UNSNAT),
                         .priority         = 100,
                         .__match          = __match,
                         .actions          = "ct_snat;",
                         .external_ids     = map_empty());

                    /* Traffic received on other router ports must be
                     * redirected to the central instance of the l3dgw_port
                     * for NAT processing. */
                    Flow(.logical_datapath = dpname,
                         .stage         = router_stage(IN, UNSNAT),
                         .priority         = 50,
                         .__match          = "ip && ip4.dst == ${nat.external_ip}",
                         .actions          = "${rEGBIT_NAT_REDIRECT()} = 1; next;",
                         .external_ids     = map_empty())
                }
            };

            /* Ingress DNAT table: Packets enter the pipeline with destination
             * IP address that needs to be DNATted from a external IP address
             * to a logical IP address. */
            if (nat.__type == "dnat" or nat.__type == "dnat_and_snat") {
                if (l3dgw_port == None) {
                    /* Gateway router. */
                    /* Packet when it goes from the initiator to destination.
                     * We need to set flags.loopback because the router can
                     * send the packet back through the same interface. */
                    var actions = if (is_some(get_force_snat_ip(lr, "dnat"))) {
                                      /* Indicate to the future tables that a DNAT has taken
                                       * place and a force SNAT needs to be done in the
                                       * Egress SNAT table. */
                                      "flags.force_snat_for_dnat = 1; "
                                  } else { "" } ++
                                  "flags.loopback = 1; ct_dnat(${nat.logical_ip});" in
                    Flow(.logical_datapath = dpname,
                         .stage         = router_stage(IN, DNAT),
                         .priority         = 100,
                         .__match          = "ip && ip4.dst == ${nat.external_ip}",
                         .actions          = actions,
                         .external_ids     = map_empty())
                };

                Some{var gwport} = l3dgw_port in {
                    /* Distributed router. */
                    /* Traffic received on l3dgw_port is subject to NAT. */
                    var __match =
                        "ip && ip4.dst == ${nat.external_ip}"
                        " && inport == ${json_string_escape(gwport.name)}" ++
                        if (mac == None) {
                            /* Flows for NAT rules that are centralized are only
                             * programmed on the "redirect-chassis". */
                            " && is_chassis_resident(${redirect_port_name})"
                        } else { "" } in
                    Flow(.logical_datapath = dpname,
                         .stage         = router_stage(IN, DNAT),
                         .priority         = 100,
                         .__match          = __match,
                         .actions          = "ct_dnat(${nat.logical_ip});",
                         .external_ids     = map_empty());

                    /* Traffic received on other router ports must be
                     * redirected to the central instance of the l3dgw_port
                     * for NAT processing. */
                    Flow(.logical_datapath = dpname,
                         .stage         = router_stage(IN, DNAT),
                         .priority         = 50,
                         .__match          = "ip && ip4.dst == ${nat.external_ip}",
                         .actions          = "${rEGBIT_NAT_REDIRECT()} = 1; next;",
                         .external_ids     = map_empty())
                }
            };

            /* Egress UNDNAT table: It is for already established connections'
             * reverse traffic. i.e., DNAT has already been done in ingress
             * pipeline and now the packet has entered the egress pipeline as
             * part of a reply. We undo the DNAT here.
             *
             * Note that this only applies for NAT on a distributed router.
             * Undo DNAT on a gateway router is done in the ingress DNAT
             * pipeline stage. */
            if ((nat.__type == "dnat" or nat.__type == "dnat_and_snat")) {
                Some{var gwport} = l3dgw_port in
                var __match =
                    "ip && ip4.src == ${nat.logical_ip}"
                    " && outport == ${json_string_escape(gwport.name)}" ++
                    if (mac == None) {
                        /* Flows for NAT rules that are centralized are only
                         * programmed on the "redirect-chassis". */
                        " && is_chassis_resident(${redirect_port_name})"
                    } else { "" } in
                var actions =
                    match (mac) {
                        Some{mac_addr} -> "eth.src = ${mac_addr}; ",
                        None -> ""
                    } ++ "ct_dnat;" in
                Flow(.logical_datapath = dpname,
                     .stage         = router_stage(OUT, UNDNAT),
                     .priority         = 100,
                     .__match          = __match,
                     .actions          = actions,
                     .external_ids     = map_empty())
            };

            /* Egress SNAT table: Packets enter the egress pipeline with
             * source ip address that needs to be SNATted to a external ip
             * address. */
            if (nat.__type == "snat" or nat.__type == "dnat_and_snat") {
                if (l3dgw_port == None) {
                    /* Gateway router. */

                    /* The priority here is calculated such that the
                     * nat->logical_ip with the longest mask gets a higher
                     * priority. */
                    Flow(.logical_datapath = dpname,
                         .stage         = router_stage(OUT, SNAT),
                         .priority         = 56'd0 ++ (count_1bits(32'd0 ++ ntohl(mask)) + 8'd1),
                         .__match          = "ip && ip4.src == ${nat.logical_ip}",
                         .actions          = "ct_snat(${nat.external_ip});",
                         .external_ids     = map_empty())
                };

                Some{var gwport} = l3dgw_port in
                {
                    /* Distributed router. */
                    var __match =
                        "ip && ip4.src == ${nat.logical_ip}"
                        " && outport == ${json_string_escape(gwport.name)}" ++
                        if (mac == None) {
                            /* Flows for NAT rules that are centralized are only
                             * programmed on the "redirect-chassis". */
                            " && is_chassis_resident(${redirect_port_name})"
                        } else { "" } in
                    var actions =
                        match (mac) {
                            Some{mac_addr} -> "eth.src = ${mac_addr}; ",
                            _ -> ""
                        } ++
                        "ct_snat(${nat.external_ip});" in
                    /* The priority here is calculated such that the
                     * nat->logical_ip with the longest mask gets a higher
                     * priority. */
                    Flow(.logical_datapath = dpname,
                         .stage         = router_stage(OUT, SNAT),
                         .priority         = 56'd0 ++ (count_1bits(32'd0 ++ ntohl(mask)) + 8'd1),
                         .__match          = __match,
                         .actions          = actions,
                         .external_ids     = map_empty())
                }
            };

            /* Logical router ingress table 0:
             * For NAT on a distributed router, add rules allowing
             * ingress traffic with eth.dst matching nat->external_mac
             * on the l3dgw_port instance where nat->logical_port is
             * resident. */
            Some{var mac_addr} = mac in
            Some{var gwport} = l3dgw_port in
            Some{var logical_port} = set_nth(nat.logical_port, 0) in
            var __match =
                "eth.dst == ${mac_addr} && inport == ${json_string_escape(gwport.name)}"
                " && is_chassis_resident(\"${logical_port}\")" in
            Flow(.logical_datapath = dpname,
                 .stage         = router_stage(IN, ADMISSION),
                 .priority         = 50,
                 .__match          = __match,
                 .actions          = "next;",
                 .external_ids     = map_empty());

            /* Ingress Gateway Redirect Table: For NAT on a distributed
             * router, add flows that are specific to a NAT rule.  These
             * flows indicate the presence of an applicable NAT rule that
             * can be applied in a distributed manner. */
            Some{var mac_addr} = mac in
            Some{var gwport} = l3dgw_port in
            var __match =
                "ip4.src == ${nat.logical_ip} && outport == ${json_string_escape(gwport.name)}" in
            Flow(.logical_datapath = dpname,
                 .stage         = router_stage(IN, GW_REDIRECT),
                 .priority         = 100,
                 .__match          = __match,
                 .actions          = "next;",
                 .external_ids     = map_empty());

            /* Egress Loopback table: For NAT on a distributed router.
             * If packets in the egress pipeline on the distributed
             * gateway port have ip.dst matching a NAT external IP, then
             * loop a clone of the packet back to the beginning of the
             * ingress pipeline with inport = outport. */
            Some{var gwport} = l3dgw_port in
            /* Distributed router. */
            var __match = "ip4.dst == ${nat.external_ip} && outport == ${json_string_escape(gwport.name)}" in
            var regs = {
                var regs: Vec<string> = vec_empty();
                for (j in range(32'd0, mFF_N_LOG_REGS()-32'd1, 32'd1)) {
                    vec_push(regs, "reg${j} = 0; ")
                };
                regs
            } in
            var actions =
                "clone { ct_clear; "
                "inport = outport; outport = \"\"; "
                "flags = 0; flags.loopback = 1; "    ++
                string_join(regs, "")                ++
                "${rEGBIT_EGRESS_LOOPBACK()} = 1; "
                "next(pipeline=ingress, table=0); };" in
            Flow(.logical_datapath = dpname,
                 .stage         = router_stage(OUT, EGR_LOOP),
                 .priority         = 100,
                 .__match          = __match,
                 .actions          = actions,
                 .external_ids     = map_empty())
        }
    };

    /* Handle force SNAT options set in the gateway router. */
    Some{(var dnat_force_snat_ip, _)} = get_force_snat_ip(lr, "dnat") in
    if (l3dgw_port == None) {
        /* If a packet with destination IP address as that of the
         * gateway router (as set in options:dnat_force_snat_ip) is seen,
         * UNSNAT it. */
        Flow(.logical_datapath = dpname,
             .stage         = router_stage(IN, UNSNAT),
             .priority         = 110,
             .__match          = "ip && ip4.dst == ${dnat_force_snat_ip}",
             .actions          = "ct_snat;",
             .external_ids     = map_empty());

        /* Higher priority rules to force SNAT with the IP addresses
         * configured in the Gateway router.  This only takes effect
         * when the packet has already been DNATed once. */
        Flow(.logical_datapath = dpname,
             .stage         = router_stage(OUT, SNAT),
             .priority         = 100,
             .__match          = "flags.force_snat_for_dnat == 1 && ip",
             .actions          = "ct_snat(${dnat_force_snat_ip});",
             .external_ids     = map_empty())
    };

    Some{(var lb_force_snat_ip, _)} = get_force_snat_ip(lr, "lb") in
    if (l3dgw_port == None) {
        /* If a packet with destination IP address as that of the
         * gateway router (as set in options:lb_force_snat_ip) is seen,
         * UNSNAT it. */
        Flow(.logical_datapath = dpname,
             .stage         = router_stage(IN, UNSNAT),
             .priority         = 100,
             .__match          = "ip && ip4.dst == ${lb_force_snat_ip}",
             .actions          = "ct_snat;",
             .external_ids     = map_empty());

        /* Load balanced traffic will have flags.force_snat_for_lb set.
         * Force SNAT it. */
        Flow(.logical_datapath = dpname,
             .stage         = router_stage(OUT, SNAT),
             .priority         = 100,
             .__match          = "flags.force_snat_for_lb == 1 && ip",
             .actions          = "ct_snat(${lb_force_snat_ip});",
             .external_ids     = map_empty())
    };

    if (l3dgw_port == None) {
        /* For gateway router, re-circulate every packet through
        * the DNAT zone.  This helps with the following.
        *
        * Any packet that needs to be unDNATed in the reverse
        * direction gets unDNATed. Ideally this could be done in
        * the egress pipeline. But since the gateway router
        * does not have any feature that depends on the source
        * ip address being external IP address for IP routing,
        * we can do it here, saving a future re-circulation. */
        Flow(.logical_datapath = dpname,
             .stage            = router_stage(IN, DNAT),
             .priority         = 50,
             .__match          = "ip",
             .actions          = "flags.loopback = 1; ct_dnat;",
             .external_ids     = map_empty())
    } else {
        /* For NAT on a distributed router, add flows to Ingress
         * IP Routing table, Ingress ARP Resolution table, and
         * Ingress Gateway Redirect Table that are not specific to a
         * NAT rule. */

        /* The highest priority IN_IP_ROUTING rule matches packets
         * with REGBIT_NAT_REDIRECT (set in DNAT or UNSNAT stages),
         * with action "ip.ttl--; next;".  The IN_GW_REDIRECT table
         * will take care of setting the outport. */
        Flow(.logical_datapath = dpname,
             .stage         = router_stage(IN, IP_ROUTING),
             .priority         = 300,
             .__match          = "${rEGBIT_NAT_REDIRECT()} == 1",
             .actions          = "ip.ttl--; next;",
             .external_ids     = map_empty());

        /* The highest priority IN_ARP_RESOLVE rule matches packets
         * with REGBIT_NAT_REDIRECT (set in DNAT or UNSNAT stages),
         * then sets eth.dst to the distributed gateway port's
         * ethernet address. */
        Some{var gwport} = l3dgw_port in
        for (&RouterPort(.lrp = nb.Logical_Router_Port{._uuid = gwport._uuid}, .networks = networks)) {
            Flow(.logical_datapath = dpname,
                 .stage         = router_stage(IN, ARP_RESOLVE),
                 .priority         = 200,
                 .__match          = "${rEGBIT_NAT_REDIRECT()} == 1",
                 .actions          = "eth.dst = ${networks.ea_s}; next;",
                 .external_ids     = map_empty())
        };

        /* The highest priority IN_GW_REDIRECT rule redirects packets
         * with REGBIT_NAT_REDIRECT (set in DNAT or UNSNAT stages) to
         * the central instance of the l3dgw_port for NAT processing. */
        Some{var gwport} = l3dgw_port in
        Flow(.logical_datapath = dpname,
             .stage         = router_stage(IN, GW_REDIRECT),
             .priority         = 200,
             .__match          = "${rEGBIT_NAT_REDIRECT()} == 1",
             .actions          = "outport = ${redirect_port_name}; next;",
             .external_ids     = map_empty())
    }
}

/* Load balancing and packet defrag are only valid on
 * Gateway routers or router with gateway port. */
for (RouterLBVIP(
        .router = &Router{.dpname = dpname,
                          .lr = lr,
                          .l3dgw_port = l3dgw_port,
                          .redirect_port_name = redirect_port_name,
                          .is_gateway = is_gateway},
        .lb = &lb,
        .vip = (vip_key, vip_value))
     if is_some(l3dgw_port) or is_gateway)
{
    if (vip_value == "") {
            for (HasEventElbMeter(has_elb_meter)) {
                Some {(var __match, var __action)} =
                    build_empty_lb_event_flow(vip_key, lb, has_elb_meter) in
                Flow(.logical_datapath = dpname,
                     .stage            = router_stage(IN, DNAT),
                     .priority         = 130,
                     .__match          = __match,
                     .actions          = __action,
                     .external_ids     = map_empty())
            }
    };

    /* A set to hold all ips that need defragmentation and tracking. */

    /* vip_key contains IP:port or just IP. */
    Some{(var ip_address, var port, var addr_family)} = ip_address_and_port_from_lb_key(vip_key) in {
        /* If there are any load balancing rules, we should send
         * the packet to conntrack for defragmentation and
         * tracking.  This helps with two things.
         *
         * 1. With tracking, we can send only new connections to
         *    pick a DNAT ip address from a group.
         * 2. If there are L4 ports in load balancing rules, we
         *    need the defragmentation to match on L4 ports. */
        var __match =
            if (addr_family == aF_INET()) {
                "ip && ip4.dst == ${ip_address}"
            } else {
                "ip && ip6.dst == ${ip_address}"
            } in
        /* One of these flows must be created for each unique LB VIP address.
         * We create one for each VIP:port pair; flows with the same IP and
         * different port numbers will produce identical flows that will
         * get merged by DDlog. */
        Flow(.logical_datapath = dpname,
             .stage         = router_stage(IN, DEFRAG),
             .priority         = 100,
             .__match          = __match,
             .actions          = "ct_next;",
             .external_ids     = map_empty());

        /* Higher priority rules are added for load-balancing in DNAT
         * table.  For every match (on a VIP[:port]), we add two flows
         * via add_router_lb_flow().  One flow is for specific matching
         * on ct.new with an action of "ct_lb($targets);".  The other
         * flow is for ct.est with an action of "ct_dnat;". */
        var match1 =
            if (addr_family == aF_INET()) {
                "ip && ip4.dst == ${ip_address}"
            } else {
                "ip && ip6.dst == ${ip_address}"
            } in
        var is_udp =
            match (set_nth(lb.protocol, 0)) {
                Some{"udp"} -> true,
                _           -> false
            } in
        (var prio, var match2) =
            if (port != 0) {
                (120: integer, if (is_udp) {
                          " && udp && udp.dst == ${port}"
                      } else {
                          " && tcp && tcp.dst == ${port}"
                      })
            } else {
                (110: integer, "")
            } in
        var __match = match1 ++ match2 ++
            match (l3dgw_port) {
                Some{gwport} -> " && is_chassis_resident(${redirect_port_name})",
                _ -> ""
            } in
        var lb_force_snat_ip = get_force_snat_ip(lr, "lb") in
        {
            /* A match and actions for new connections. */
            var new_match = "ct.new && " ++ __match in
            var actions =
                match (lb_force_snat_ip) {
                    Some{snat_ip} -> "flags.force_snat_for_lb = 1; ct_lb(${vip_value});",
                    None -> "ct_lb(${vip_value});"
                } in
            Flow(.logical_datapath = dpname,
                 .stage         = router_stage(IN, DNAT),
                 .priority         = prio,
                 .__match          = new_match,
                 .actions          = actions,
                 .external_ids     = map_empty());

            /* A match and actions for established connections. */
            var est_match = "ct.est && " ++ __match in
            var actions =
                match (lb_force_snat_ip) {
                    Some{snat_ip} -> "flags.force_snat_for_lb = 1; ct_dnat;",
                    None -> "ct_dnat;"
                } in
            Flow(.logical_datapath = dpname,
                 .stage         = router_stage(IN, DNAT),
                 .priority         = prio,
                 .__match          = est_match,
                 .actions          = actions,
                 .external_ids     = map_empty());

            Some{var gwport} = l3dgw_port in
            /* Add logical flows to UNDNAT the load balanced reverse traffic in
             * the router egress pipleine stage - S_ROUTER_OUT_UNDNAT if the logical
             * router has a gateway router port associated.
             */
            var conds = {
                var conds: Vec<string> = vec_empty();
                for (ip_str in string_split(vip_value, ",")) {
                    match (ip_address_and_port_from_lb_key(ip_str)) {
                        None -> () /* FIXME: put a break here */,
                        Some{(ip_address_, port_, addr_family_)} -> vec_push(conds,
                            if (addr_family_ == aF_INET()) {
                                "(ip4.src == ${ip_address_}"
                            } else {
                                "(ip6.src == ${ip_address_}"
                            } ++
                            if (port_ != 0) {
                                " && ${if is_udp \"udp\" else \"tcp\"}.src == ${port_}) || "
                            } else {
                                ")"
                            })
                    }
                };
                conds
            } in
            not vec_is_empty(conds) in
            var undnat_match =
                if (addr_family == aF_INET()) { "ip4 && (" } else { "ip6 && (" }    ++
                string_join(conds, " || ")                                          ++
                ") && outport == ${json_string_escape(gwport.name)} && "
                "is_chassis_resident(${redirect_port_name})" in
            var action =
                match (lb_force_snat_ip) {
                    Some{snat_ip} -> "flags.force_snat_for_lb = 1; ct_dnat;",
                    None -> "ct_dnat;"
                } in
            Flow(.logical_datapath = dpname,
                 .stage         = router_stage(OUT, UNDNAT),
                 .priority         = 120,
                 .__match          = undnat_match,
                 .actions          = action,
                 .external_ids     = map_empty())
        }
    }
}

/* Defaults based on MaxRtrInterval and MinRtrInterval from RFC 4861 section
 * 6.2.1
 */
function nD_RA_MAX_INTERVAL_DEFAULT(): integer = 600

function nd_ra_min_interval_default(max: integer): integer =
{
    if (max >= 9) { max / 3 } else { max * 3 / 4 }
}

function nD_RA_MAX_INTERVAL_MAX(): integer = 1800
function nD_RA_MAX_INTERVAL_MIN(): integer = 4

function nD_RA_MIN_INTERVAL_MAX(max: integer): integer = ((max * 3) / 4)
function nD_RA_MIN_INTERVAL_MIN(): integer = 3

function nD_MTU_DEFAULT(): integer = 0

function copy_ra_to_sb(port: RouterPort, address_mode: string): Map<string, string> =
{
    var options: Map<string, string> = map_empty();

    map_insert(options, "ipv6_ra_send_periodic", "true");
    map_insert(options, "ipv6_ra_address_mode", address_mode);

    var max_interval = map_get_int_def(port.lrp.ipv6_ra_configs, "max_interval",
            nD_RA_MAX_INTERVAL_DEFAULT());

    if (max_interval > nD_RA_MAX_INTERVAL_MAX()) {
        max_interval = nD_RA_MAX_INTERVAL_MAX()
    } else ();

    if (max_interval < nD_RA_MAX_INTERVAL_MIN()) {
        max_interval = nD_RA_MAX_INTERVAL_MIN()
    } else ();

    map_insert(options, "ipv6_ra_max_interval", "${max_interval}");

    var min_interval = map_get_int_def(port.lrp.ipv6_ra_configs,
            "min_interval", nd_ra_min_interval_default(max_interval));

    if (min_interval > nD_RA_MIN_INTERVAL_MAX(max_interval)) {
        min_interval = nD_RA_MIN_INTERVAL_MAX(max_interval)
    } else ();

    if (min_interval < nD_RA_MIN_INTERVAL_MIN()) {
        min_interval = nD_RA_MIN_INTERVAL_MIN()
    } else ();

    map_insert(options, "ipv6_ra_min_interval", "${min_interval}");

    var mtu = map_get_int_def(port.lrp.ipv6_ra_configs, "mtu", nD_MTU_DEFAULT());

    /* RFC 2460 requires the MTU for IPv6 to be at least 1280 */
    if (mtu != 0 and mtu >= 1280) {
        map_insert(options, "ipv6_ra_mtu", "${mtu}")
    } else ();

    var prefixes: Vec<string> = vec_empty();
    for (addrs in port.networks.ipv6_addrs) {
        if (in6_is_lla(addrs.network)) {
            map_insert(options, "ipv6_ra_src_addr", addrs.addr_s)
        } else {
            vec_push(prefixes, "${addrs.network_s}/${addrs.plen}")
        }
    };

    /* Remove trailing space */
    map_insert(options, "ipv6_ra_prefixes", string_join(prefixes, " "));

    map_insert(options, "ipv6_ra_src_eth", port.networks.ea_s);
    options
}

/* Logical router ingress table 5 and 6: IPv6 Router Adv (RA) options and
 * response. */
// FIXME: do these rules apply to derived ports?
for (&RouterPort[port@RouterPort{.lrp = lrp@nb.Logical_Router_Port{.peer = set_empty()},
                                 .router = &router,
                                 .json_name = json_name,
                                 .networks = networks,
                                 .peer = PeerSwitch{}}]
     if (not vec_is_empty(networks.ipv6_addrs)))
{
    Some{var address_mode} = map_get(lrp.ipv6_ra_configs, "address_mode") in
    /* FIXME: we need a nicer wat to write this */
    true ==
        if ((address_mode != "slaac") and
            (address_mode != "dhcpv6_stateful") and
            (address_mode != "dhcpv6_stateless")) {
            warn("Invalid address mode [${address_mode}] defined");
            false
        } else { true } in
    {
        if (map_get_bool_def(lrp.ipv6_ra_configs, "send_periodic", false)) {
            RouterPortRAOptions(lrp._uuid, copy_ra_to_sb(port, address_mode))
        };

        (true, var prefix) =
            {
                var add_rs_response_flow = false;
                var prefix = "";
                for (addr in networks.ipv6_addrs) {
                    if (not in6_is_lla(addr.network)) {
                        prefix = prefix ++ ", prefix = ${addr.network_s}/${addr.plen}";
                        add_rs_response_flow = true
                    } else ()
                };
                (add_rs_response_flow, prefix)
            } in
        {
            var __match = "inport == ${json_name} && ip6.dst == ff02::2 && nd_rs" in
            /* As per RFC 2460, 1280 is minimum IPv6 MTU. */
            var mtu: integer = match(map_get(lrp.ipv6_ra_configs, "mtu")) {
                    Some{mtu_s} -> {
                        match (str_to_int(mtu_s, 10)) {
                            None -> 0,
                            Some{mtu} -> if (mtu >= 64'd1280) mtu else 0
                        }
                    },
                    None -> 0
                } in
            var actions0 =
                "${rEGBIT_ND_RA_OPTS_RESULT()} = put_nd_ra_opts("
                "addr_mode = \"${address_mode}\", slla = ${networks.ea_s}" ++
                if (mtu > 0) { ", mtu = ${mtu}" } else { "" } in
            var actions = actions0 ++ prefix ++ "); next;" in
            Flow(.logical_datapath = router.dpname,
                 .stage         = router_stage(IN, ND_RA_OPTIONS),
                 .priority         = 50,
                 .__match          = __match,
                 .actions          = actions,
                 .external_ids     = map_empty());

            var __match = "inport == ${json_name} && ip6.dst == ff02::2 && "
                          "nd_ra && ${rEGBIT_ND_RA_OPTS_RESULT()}" in
            var ip6_str = ipv6_string_mapped(in6_generate_lla(networks.ea)) in
            var actions = "eth.dst = eth.src; eth.src = ${networks.ea_s}; "
                          "ip6.dst = ip6.src; ip6.src = ${ip6_str}; "
                          "outport = inport; flags.loopback = 1; "
                          "output;" in
            Flow(.logical_datapath = router.dpname,
                 .stage         = router_stage(IN, ND_RA_RESPONSE),
                 .priority         = 50,
                 .__match          = __match,
                 .actions          = actions,
                 .external_ids     = map_empty())
        }
    }
}


/* Logical router ingress table 5, 6: RS responder, by default goto next.
 * (priority 0)*/
for (&Router(.dpname = dpname))
{
    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, ND_RA_OPTIONS),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty());
    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, ND_RA_RESPONSE),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty())
}

/* Proxy table that stores per-port routes.
 * There routes get converted into logical flows by
 * the following rule.
 */
relation Route(port_name:   string,
               networks:    lport_addresses,
               router:      Ref<Router>,
               addr_s:      string,
               network_s:   string,
               plen:        bit<32>,
               gateway:     Option<string>,
               policy:      Option<string>)

for (Route(.port_name   = port_name,
           .networks    = networks,
           .router      = &router,
           .addr_s      = addr_s,
           .network_s   = network_s,
           .plen        = plen,
           .gateway     = gateway,
           .policy      = policy))
{
    var is_ipv4 = if string_contains(network_s, ".") true else false in
    (var dir, var priority) =
        if (policy == Some{"src-ip"}) {
            ("src", plen * 32'd2)
        } else {
            ("dst", (plen * 32'd2) + 32'd1)
        } in
    /* IPv6 link-local addresses must be scoped to the local router port. */
    var __match =
        if (not is_ipv4) {
            match (ipv6_parse(network_s)) {
                Some{network} -> {
                    if (in6_is_lla(network)) {
                        "inport == ${port_name} && "
                    } else ""
                },
                None -> {
                    abort("invalid IPv6 address ${network_s}");
                    ""
                }
            }
        } else { "" } ++
        "ip${if is_ipv4 \"4\" else \"6\"}.${dir} == ${network_s}/${plen}" in
    var actions =
        "ip.ttl--; ${if is_ipv4 \"\" else \"xx\"}reg0 = " ++
        match (gateway) {
            Some{gw} -> gw,
            None     -> "ip${if is_ipv4 \"4\" else \"6\"}.dst"
        } ++
        "; "
        "${if is_ipv4 \"\" else \"xx\"}reg1 = ${addr_s}; "
        "eth.src = ${networks.ea_s}; "
        "outport = ${port_name}; "
        "flags.loopback = 1; "
        "next;" in
    /* The priority here is calculated to implement longest-prefix-match
     * routing. */
    Flow(.logical_datapath = router.dpname,
         .stage         = router_stage(IN, IP_ROUTING),
         .priority         = 32'd0 ++ priority,
         .__match          = __match,
         .actions          = actions,
         .external_ids     = map_empty())
}

/* Logical router ingress table 7: IP Routing.
 *
 * A packet that arrives at this table is an IP packet that should be
 * routed to the address in 'ip[46].dst'. This table sets outport to
 * the correct output port, eth.src to the output port's MAC
 * address, and '[xx]reg0' to the next-hop IP address (leaving
 * 'ip[46].dst', the packet’s final destination, unchanged), and
 * advances to the next table for ARP/ND resolution. */
for (RouterPortNetworksIPv4Addr(.port = &port@RouterPort{.router = &router}, .addr = addr))
{
    Route(port.json_name, port.networks, port.router,
          addr.addr_s, addr.network_s, addr.plen, None, None)//;
    /* create identical route for redirect port */
    // FIXME: is this correct?
    /*if (port.is_redirect) {
        Route(router.redirect_port_name, port.networks, port.router,
              addr.addr_s, addr.network_s, addr.plen, None, None)
    }*/
}

for (RouterPortNetworksIPv6Addr(.port = &port@RouterPort{.router = &router}, .addr = addr))
{
    Route(port.json_name, port.networks, port.router,
          addr.addr_s, addr.network_s, addr.plen, None, None)//;
    /* create identical route for redirect port */
    /*if (port.is_redirect) {
        Route(router.redirect_port_name, port.networks, port.router,
              addr.addr_s, addr.network_s, addr.plen, None, None)
    }*/
}

/* Convert the static routes to flows. */
for (RouterStaticRoute(.router      = &router,
                       .route       = &route,
                       .output_port = &out_port,
                       .lrp_addr_s  = lrp_addr_s))
{
    var policy =
        match (set_nth(route.lrsr.policy, 0)) {
            Some{policy} -> policy,
            None -> "dst-ip"
        } in
    {
        Route(out_port.json_name, out_port.networks, out_port.router,
              lrp_addr_s, route.prefix_s, route.plen,
              Some{route.lrsr.nexthop}, Some{policy})//;
        /*if (out_port.is_redirect) {
            Route(router.redirect_port_name, out_port.networks, out_port.router,
                  lrp_addr_s, route.prefix_s, route.plen,
                  Some{route.lrsr.nexthop}, Some{policy})
        }*/
    }
}

/* IP Multicast lookup. Here we set the output port, adjust TTL and advance
 * to next table (priority 500).
 */
for (IgmpRouterMulticastGroup(address, &rtr, ports)) {
    for (RouterMcastFloodPorts(&rtr, flood_ports)) {
        var flood_static = not set_is_empty(flood_ports) in
        (var mc_static, _) = mC_STATIC() in
        var static_act = {
            if (flood_static) {
                "clone { "
                    "outport = \"${mc_static}\"; "
                    "ip.ttl--; "
                    "next; "
                "};"
            } else {
                ""
            }
        } in
        Flow(.logical_datapath = rtr.dpname,
             .stage            = router_stage(IN, IP_ROUTING),
             .priority         = 500,
             .__match          = "ip4 && ip4.dst == ${address}",
             .actions          =
                "${static_act} outport = \"${address}\"; ip.ttl--; next;",
             .external_ids     = map_empty())
    }
}

/* If needed, flood unregistered multicast on statically configured ports.
 * Priority 450.
 */
for (RouterMcastFloodPorts(&rtr, flood_ports)) {
    (var mc_static, _) = mC_STATIC() in
    Flow(.logical_datapath = rtr.dpname,
         .stage            = router_stage(IN, IP_ROUTING),
         .priority         = 450,
         .__match          = "ip4.mcast",
         .actions          =
            "clone { outport = \"${mc_static}\"; ip.ttl--; next;};",
         .external_ids     = map_empty())
}

/* XXX destination unreachable */

/* Local router ingress table 8: ARP Resolution.
 *
 * Multicast packets already have the outport set so just advance to next
 * table (priority 500).
 */
for (&Router(.dpname = dpname)) {
    Flow(.logical_datapath = dpname,
         .stage            = router_stage(IN, ARP_RESOLVE),
         .priority         = 500,
         .__match          = "ip4.mcast",
         .actions          = "next;",
         .external_ids     = map_empty())
}

/* Local router ingress table 8: ARP Resolution.
 *
 * Any packet that reaches this table is an IP packet whose next-hop IP
 * address is in reg0. (ip4.dst is the final destination.) This table
 * resolves the IP address in reg0 into an output port in outport and an
 * Ethernet address in eth.dst. */
// FIXME: does this apply to redirect ports?
for (&RouterPort(.peer = PeerRouter{peer_port, _},
                 .router = &router,
                 .networks = networks))
{
    for (&RouterPort(.lrp = nb.Logical_Router_Port{._uuid = peer_port},
                     .json_name = peer_json_name,
                     .router = &peer_router))
    {
        /* This is a logical router port. If next-hop IP address in
         * '[xx]reg0' matches IP address of this router port, then
         * the packet is intended to eventually be sent to this
         * logical port. Set the destination mac address using this
         * port's mac address.
         *
         * The packet is still in peer's logical pipeline. So the match
         * should be on peer's outport. */
        if (not vec_is_empty(networks.ipv4_addrs)) {
            var __match = "outport == ${peer_json_name} && reg0 == " ++
                          format_v4_networks(networks, false) in
            Flow(.logical_datapath = peer_router.dpname,
                 .stage         = router_stage(IN, ARP_RESOLVE),
                 .priority         = 100,
                 .__match          = __match,
                 .actions          = "eth.dst = ${networks.ea_s}; next;",
                 .external_ids     = map_empty())
        };

        if (not vec_is_empty(networks.ipv6_addrs)) {
            var __match = "outport == ${peer_json_name} && xxreg0 == " ++
                          format_v6_networks(networks) in
            Flow(.logical_datapath = peer_router.dpname,
                 .stage         = router_stage(IN, ARP_RESOLVE),
                 .priority         = 100,
                 .__match          = __match,
                 .actions          = "eth.dst = ${networks.ea_s}; next;",
                 .external_ids     = map_empty())
        }
    }
}


/* This is a logical switch port that backs a VM or a container.
 * Extract its addresses. For each of the address, go through all
 * the router ports attached to the switch (to which this port
 * connects) and if the address in question is reachable from the
 * router port, add an ARP/ND entry in that router's pipeline. */
for (SwitchPortIPv4Address(
        .port = &SwitchPort{.lsp = lsp, .sw = &sw},
        .ea_s = ea_s,
        .addr = addr)
     if lsp.__type != "router" and is_enabled(lsp.enabled))
{
    for (&SwitchPort(.sw = &Switch{.ls = nb.Logical_Switch{._uuid = sw.ls._uuid}},
                     .peer = Some{&peer@RouterPort{.router = &peer_router}}))
    {
        Some{_} = find_lrp_member_ip(peer.networks, addr.addr_s) in
        Flow(.logical_datapath = peer_router.dpname,
             .stage         = router_stage(IN, ARP_RESOLVE),
             .priority         = 100,
             .__match          = "outport == ${peer.json_name} && reg0 == ${addr.addr_s}",
             .actions          = "eth.dst = ${ea_s}; next;",
             .external_ids     = map_empty())
    }
}

for (SwitchPortIPv6Address(
        .port = &SwitchPort{.lsp = lsp, .sw = &sw},
        .ea_s = ea_s,
        .addr = addr)
     if lsp.__type != "router" and is_enabled(lsp.enabled))
{
    for (&SwitchPort(.sw = &Switch{.ls = nb.Logical_Switch{._uuid = sw.ls._uuid}},
                     .peer = Some{&peer@RouterPort{.router = &peer_router}}))
    {
        Some{_} = find_lrp_member_ip(peer.networks, addr.addr_s) in
        Flow(.logical_datapath = peer_router.dpname,
             .stage         = router_stage(IN, ARP_RESOLVE),
             .priority         = 100,
             .__match          = "outport == ${peer.json_name} && xxreg0 == ${addr.addr_s}",
             .actions          = "eth.dst = ${ea_s}; next;",
             .external_ids     = map_empty())
    }
}


/* This is a logical switch port that connects to a router. */

/* The peer of this switch port is the router port for which
 * we need to add logical flows such that it can resolve
 * ARP entries for all the other router ports connected to
 * the switch in question. */
for (&SwitchPort(.lsp = lsp1,
                 .peer = Some{&peer1@RouterPort{.router = &peer_router}},
                 .sw = &sw)
     if is_enabled(lsp1.enabled))
{
    for (&SwitchPort(.lsp = lsp2, .peer = Some{&peer2},
                     .sw = &Switch{.ls = nb.Logical_Switch{._uuid = sw.ls._uuid}})
         /* Skip the router port under consideration. */
         if peer2.lrp._uuid != peer1.lrp._uuid)
    {
        if (not vec_is_empty(peer2.networks.ipv4_addrs)) {
            Flow(.logical_datapath = peer_router.dpname,
                 .stage         = router_stage(IN, ARP_RESOLVE),
                 .priority         = 100,
                 .__match          = "outport == ${peer1.json_name} && reg0 == ${format_v4_networks(peer2.networks, false)}",
                 .actions          = "eth.dst = ${peer2.networks.ea_s}; next;",
                 .external_ids     = map_empty())
        };

        if (not vec_is_empty(peer2.networks.ipv6_addrs)) {
            Flow(.logical_datapath = peer_router.dpname,
                 .stage         = router_stage(IN, ARP_RESOLVE),
                 .priority         = 100,
                 .__match          = "outport == ${peer1.json_name} && xxreg0 == ${format_v6_networks(peer2.networks)}",
                 .actions          = "eth.dst = ${peer2.networks.ea_s}; next;",
                 .external_ids     = map_empty())
        }
    }
}

for (&Router(.dpname = dpname))
{
    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, ARP_RESOLVE),
         .priority         = 0,
         .__match          = "ip4",
         .actions          = "get_arp(outport, reg0); next;",
         .external_ids     = map_empty());
    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, ARP_RESOLVE),
         .priority         = 0,
         .__match          = "ip6",
         .actions          = "get_nd(outport, xxreg0); next;",
         .external_ids     = map_empty())
}


/* Logical router ingress table 9: Gateway redirect.
 *
 * For traffic with outport equal to the l3dgw_port
 * on a distributed router, this table redirects a subset
 * of the traffic to the l3redirect_port which represents
 * the central instance of the l3dgw_port.
 */
for (&Router(.dpname = dpname,
             .l3dgw_port = l3dgw_port,
             .redirect_port_name = redirect_port_name))
{
    Some{var gwport} = l3dgw_port in
    {
        /* For traffic with outport == l3dgw_port, if the
         * packet did not match any higher priority redirect
         * rule, then the traffic is redirected to the central
         * instance of the l3dgw_port. */
        Flow(.logical_datapath = dpname,
             .stage         = router_stage(IN, GW_REDIRECT),
             .priority         = 50,
             .__match          = "outport == ${json_string_escape(gwport.name)}",
             .actions          = "outport = ${redirect_port_name}; next;",
             .external_ids     = map_empty());

        /* If the Ethernet destination has not been resolved,
         * redirect to the central instance of the l3dgw_port.
         * Such traffic will be replaced by an ARP request or ND
         * Neighbor Solicitation in the ARP request ingress
         * table, before being redirected to the central instance.
         */
        Flow(.logical_datapath = dpname,
             .stage         = router_stage(IN, GW_REDIRECT),
             .priority         = 150,
             .__match          = "outport == ${json_string_escape(gwport.name)} && eth.dst == 00:00:00:00:00:00",
             .actions          = "outport = ${redirect_port_name}; next;",
             .external_ids     = map_empty())
    };

    /* Packets are allowed by default. */
    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, GW_REDIRECT),
         .priority         = 0,
         .__match          = "1",
         .actions          = "next;",
         .external_ids     = map_empty())
}

/* Local router ingress table 10: ARP request.
 *
 * In the common case where the Ethernet destination has been resolved,
 * this table outputs the packet (priority 0).  Otherwise, it composes
 * and sends an ARP/IPv6 NA request (priority 100). */

for (RouterStaticRoute(.router      = &router,
                       .route       = &route,
                       .output_port = &out_port,
                       .lrp_addr_s  = lrp_addr_s))
{
    Right{(var gw_ip6, 128)} = ipv6_parse_cidr(route.lrsr.nexthop) in
    var __match = "eth.dst == 00:00:00:00:00:00 && "
                  "ip6 && xxreg0 == ${route.lrsr.nexthop}" in
    var sn_addr = in6_addr_solicited_node(gw_ip6) in
    var eth_dst = ipv6_multicast_to_ethernet(sn_addr) in
    var sn_addr_s = ipv6_string_mapped(sn_addr) in
    var actions = "nd_ns { "
                  "eth.dst = ${eth_dst}; "
                  "ip6.dst = ${sn_addr_s}; "
                  "nd.target = ${route.lrsr.nexthop}; "
                  "output; "
                  "};" in
    Flow(.logical_datapath = router.dpname,
         .stage         = router_stage(IN, ARP_REQUEST),
         .priority         = 200,
         .__match          = __match,
         .actions          = actions,
         .external_ids     = map_empty())
}

for (&Router(.dpname = dpname))
{
    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, ARP_REQUEST),
         .priority         = 100,
         .__match          = "eth.dst == 00:00:00:00:00:00",
         .actions          = "arp { "
                             "eth.dst = ff:ff:ff:ff:ff:ff; "
                             "arp.spa = reg1; "
                             "arp.tpa = reg0; "
                             "arp.op = 1; " /* ARP request */
                             "output; "
                             "};",
         .external_ids     = map_empty());

    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, ARP_REQUEST),
         .priority         = 100,
         .__match          = "eth.dst == 00:00:00:00:00:00",
         .actions          = "nd_ns { "
                             "nd.target = xxreg0; "
                             "output; "
                             "};",
         .external_ids     = map_empty());

    Flow(.logical_datapath = dpname,
         .stage         = router_stage(IN, ARP_REQUEST),
         .priority         = 0,
         .__match          = "1",
         .actions          = "output;",
         .external_ids     = map_empty())
}


/* Logical router egress table 1: Delivery (priority 100).
 *
 * Priority 100 rules deliver packets to enabled logical ports. */
for (&RouterPort(.lrp = lrp,
                 .json_name = json_name,
                 .networks = lrp_networks,
                 .router = &Router{.dpname = dpname, .mcast_cfg = &mcast_cfg})
     /* Drop packets to disabled logical ports (since logical flow
      * tables are default-drop). */
     if is_enabled(lrp.enabled))
{
    /* If multicast relay is enabled then also adjust source mac for IP
     * multicast traffic.
     */
    if (mcast_cfg.relay) {
        Flow(.logical_datapath = dpname,
             .stage            = router_stage(OUT, DELIVERY),
             .priority         = 110,
             .__match          = "ip4.mcast && outport == ${json_name}",
             .actions          = "eth.src = ${lrp_networks.ea_s}; output;",
             .external_ids     = map_empty())
    };
    /* No egress packets should be processed in the context of
     * a chassisredirect port.  The chassisredirect port should
     * be replaced by the l3dgw port in the local output
     * pipeline stage before egress processing. */

    Flow(.logical_datapath = dpname,
         .stage            = router_stage(OUT, DELIVERY),
         .priority         = 100,
         .__match          = "outport == ${json_name}",
         .actions          = "output;",
         .external_ids     = map_empty())
}

/*
 * Datapath tunnel key allocation:
 *
 * Allocates a globally unique tunnel id in the range 1...2**24-1 for
 * each Logical_Switch and Logical_Router.
 */

// all tunnel keys already in use in the Realized table
relation AllocatedTunKeys(keys: Set<integer>)

AllocatedTunKeys(keys) :-
    sb.Datapath_Binding(.tunnel_key = tunkey),
    var keys = Aggregate((), group2set(tunkey)).

// Datapath_Binding's not yet in the Realized table
relation NotYetAllocatedTunKeys(datapaths: Vec<string>)

NotYetAllocatedTunKeys(datapaths) :-
    sb.UUIDMap_Datapath_Binding(.uuid_name = datapath,
                                .id = Right{_}),
    datapath != "",
    var datapaths = Aggregate((), group2vec(datapath)).

// Perform the allocation
relation TunKeyAllocation(datapath: string, tunkey: integer)

// transfer existing allocations from the realized table
TunKeyAllocation(datapath, tunkey) :-
     sb.UUIDMap_Datapath_Binding(.uuid_name = datapath,
                                 .id = Left{uuid}),
     sb.Datapath_Binding(._uuid = uuid,
                         .tunnel_key = tunkey).

// Case 1: AllocatedTunKeys relation is not empty (i.e., contains
// a single record that stores a set of allocated keys)
TunKeyAllocation(datapath, tunkey) :-
    NotYetAllocatedTunKeys(unallocated),
    AllocatedTunKeys(allocated),
    var allocation = FlatMap(allocate(allocated, unallocated, 64'h1, 64'hfffffffff)),
    (var datapath, var tunkey) = allocation.

// Case 2: AllocatedTunKeys relation is empty
TunKeyAllocation(datapath, tunkey) :-
    NotYetAllocatedTunKeys(unallocated),
    not AllocatedTunKeys(_),
    var allocation = FlatMap(allocate(set_empty():Set<bit<64>>, unallocated, 64'h1, 64'hfffffffff)),
    (var datapath, var tunkey) = allocation.

/*
 * Port id allocation:
 *
 * Port IDs in a per-datapath space in the range 1...2**15-1
 */

// all tunnel keys already in use in the Realized table
relation AllocatedPortTunKeys(datapath: string, keys: Set<integer>)

AllocatedPortTunKeys(datapath_name, keys) :-
    sb.Port_Binding(.datapath = datapath_uuid, .tunnel_key = tunkey),
    sb.UUIDMap_Datapath_Binding(datapath_name, Left{datapath_uuid}),
    var keys = Aggregate((datapath_name), group2set(tunkey)).

// Port_Binding's not yet in the Realized table
relation NotYetAllocatedPortTunKeys(datapath: string, all_logical_ids: Vec<string>)

NotYetAllocatedPortTunKeys(datapath, all_names) :-
    sb.Out_Port_Binding(.uuid_name = uuid_name, .datapath = datapath),
    sb.UUIDMap_Port_Binding(.uuid_name = uuid_name,
                            .id = Right{_}),
    var all_names = Aggregate((datapath), group2vec(uuid_name)).

// Perform the allocation
relation PortTunKeyAllocation(port: string, tunkey: integer)

// transfer existing allocations from the realized table
PortTunKeyAllocation(port, tunkey) :-
     sb.UUIDMap_Port_Binding(.uuid_name = port,
                             .id = Left{uuid}),
     sb.Port_Binding(._uuid = uuid,
                     .tunnel_key = tunkey).

// Case 1: AllocatedPortTunKeys(datapath) is not empty (i.e., contains
// a single record that stores a set of allocated keys)
PortTunKeyAllocation(port, tunkey) :-
    AllocatedPortTunKeys(datapath, allocated),
    NotYetAllocatedPortTunKeys(datapath, unallocated),
    var allocation = FlatMap(allocate(allocated, unallocated, 64'h1, 64'hffff)),
    (var port, var tunkey) = allocation.

// Case 2: PortAllocatedTunKeys(datapath) relation is empty
PortTunKeyAllocation(port, tunkey) :-
    NotYetAllocatedPortTunKeys(datapath, unallocated),
    not AllocatedPortTunKeys(datapath, _),
    var allocation = FlatMap(allocate(set_empty(): Set<bit<64>>, unallocated, 64'h1, 64'hffff)),
    (var port, var tunkey) = allocation.

/*
 * Multicast group tunnel_key allocation:
 *
 * Tunnel-keys in a per-datapath space in the range 32770...65535
 */

// all tunnel keys already in use in the Realized table
relation AllocatedMulticastGroupTunKeys(datapath: string, keys: Set<integer>)

AllocatedMulticastGroupTunKeys(datapath, keys) :-
    sb.Multicast_Group(.datapath = datapath_uuid, .tunnel_key = tunkey),
    sb.UUIDMap_Datapath_Binding(datapath, Left{datapath_uuid}),
    var keys = Aggregate((datapath), group2set(tunkey)).

// Multicast_Group's not yet in the Realized table
relation NotYetAllocatedMulticastGroupTunKeys(datapath: string,
                                              all_logical_ids: Vec<string>)

NotYetAllocatedMulticastGroupTunKeys(datapath, all_names) :-
    sb.Out_Multicast_Group(.name = name, .datapath = datapath,
                           .tunnel_key = tunnel_key),
    sb.UUIDMap_Datapath_Binding(datapath, Left{datapath_uuid}),
    not sb.Multicast_Group(.name = name, .datapath = datapath_uuid),
    var all_names = Aggregate((datapath), group2vec(name)).

// Perform the allocation
relation MulticastGroupTunKeyAllocation(group: string, tunkey: integer)

// transfer existing allocations from the realized table
MulticastGroupTunKeyAllocation(group, tunkey) :-
    sb.UUIDMap_Datapath_Binding(_, Left{datapath_uuid}),
    sb.Multicast_Group(.name = group,
                       .datapath = datapath_uuid,
                       .tunnel_key = tunkey).

// Case 1: AllocatedMulticastGroupTunKeys(datapath) is not empty (i.e.,
// contains a single record that stores a set of allocated keys)
MulticastGroupTunKeyAllocation(group, tunkey) :-
    AllocatedMulticastGroupTunKeys(datapath, allocated),
    NotYetAllocatedMulticastGroupTunKeys(datapath, unallocated),
    (_, var min_key) = mC_IP_MCAST_MIN(),
    (_, var max_key) = mC_IP_MCAST_MAX(),
    var allocation = FlatMap(allocate(allocated, unallocated,
                                      min_key, max_key)),
    (var group, var tunkey) = allocation.

// Case 2: AllocatedMulticastGroupTunKeys(datapath) relation is empty
MulticastGroupTunKeyAllocation(group, tunkey) :-
    NotYetAllocatedMulticastGroupTunKeys(datapath, unallocated),
    not AllocatedMulticastGroupTunKeys(datapath, _),
    (_, var min_key) = mC_IP_MCAST_MIN(),
    (_, var max_key) = mC_IP_MCAST_MAX(),
    var allocation = FlatMap(allocate(set_empty(): Set<bit<64>>, unallocated,
                                      min_key, max_key)),
    (var group, var tunkey) = allocation.

/*
 * Queue ID allocation
 *
 * Queue IDs on a chassis, for routers that have QoS enabled, in a per-chassis
 * space in the range 1...0xf000.  It looks to me like there'd only be a small
 * number of these per chassis, and probably a small number overall, in case it
 * matters.
 *
 * Queue ID may also need to be deallocated if port loses QoS attributes
 *
 * This logic only applies to ports with chassis attribute, i.e., they must be
 * in sb.Port_Binding.
 */

function port_has_qos_params(opts: Map<string, string>): bool = {
    map_contains_key(opts, "qos_max_rate") or
    map_contains_key(opts, "qos_burst")
}


// ports in Out_Port_Binding that require queue ID on chassis
relation PortRequiresQID(port: string, chassis: uuid)

PortRequiresQID(pb.uuid_name, chassis) :-
    sb.Out_Port_Binding[pb],
    port_has_qos_params(pb.options),
    sb.UUIDMap_Port_Binding(pb.uuid_name, Left{uuid}),
    sb.Port_Binding(._uuid = uuid, .chassis = chassis_set),
    Some{var chassis} = set_nth(chassis_set, 0).

relation AggPortRequiresQID(chassis: uuid, ports: Vec<string>)

AggPortRequiresQID(chassis, ports) :-
    PortRequiresQID(port, chassis),
    var ports = Aggregate((chassis), group2vec(port)).

relation AllocatedQIDs(chassis: uuid, allocated_ids: Map<string, integer>)

AllocatedQIDs(chassis, allocated_ids) :-
    sb.Port_Binding[pb],
    Some{var chassis} = set_nth(pb.chassis, 0),
    Some{var qid_str} = map_get(pb.options, "qdisc_queue_id"),
    Some{var qid: bit<64>} = parse_dec_u64(qid_str),
    sb.UUIDMap_Port_Binding(port, Left{pb._uuid}),
    var allocated_ids = Aggregate((chassis), group2map((port, qid))).

// allocate queueue IDs to ports
relation QueueIDAllocation(port: string, qids: Option<integer>)

// None for ports that do not require a queue
QueueIDAllocation(port, None) :-
    sb.Out_Port_Binding(.uuid_name = port),
    not PortRequiresQID(port, _).

QueueIDAllocation(port, Some{qid}) :-
    AggPortRequiresQID(chassis, ports),
    AllocatedQIDs(chassis, allocated_ids),
    var allocations = FlatMap(adjust_allocation(allocated_ids, ports, 64'h1, 64'hf000)),
    (var port, var qid) = allocations.

QueueIDAllocation(port, Some{qid}) :-
    AggPortRequiresQID(chassis, ports),
    not AllocatedQIDs(chassis, _),
    var allocations = FlatMap(adjust_allocation(map_empty(): Map<string, integer>, ports, 64'h1, 64'hf000)),
    (var port, var qid) = allocations.

/*
 * Tag allocation for nested containers.
 */

/* Reserved tags for each parent port, including:
 * 1. For ports that need a dynamically allocated tag, existing tag, if any,
 * 2. For ports that have a statically assigned tag (via `tag_request`), the
 *    `tag_request` value.
 * 3. For ports that do not have a tag_request, but have a tag statically assigned
 *    by directly setting the `tag` field, use this value.
 */
output relation SwitchPortReservedTag(parent_name: string, tags: integer)

SwitchPortReservedTag(parent_name, tag) :-
    &SwitchPort(.lsp = lsp, .needs_dynamic_tag = needs_dynamic_tag, .parent_name = Some{parent_name}),
    Some{var tag} = if (needs_dynamic_tag) {
        set_nth(lsp.tag, 0)
    } else {
        match (set_nth(lsp.tag_request, 0)) {
            Some{req} -> Some{req},
            None      -> set_nth(lsp.tag, 0)
        }
    }.

output relation SwitchPortReservedTags(parent_name: string, tags: Set<integer>)

SwitchPortReservedTags(parent_name, tags) :-
    SwitchPortReservedTag(parent_name, tag),
    var tags = Aggregate((parent_name), group2set(tag)).

SwitchPortReservedTags(parent_name, set_empty()) :-
    nb.Logical_Switch_Port(.name = parent_name),
    not SwitchPortReservedTag(.parent_name = parent_name).

/* Allocate tags for ports that require dynamically allocated tags and do not
 * have any yet.
 */
output relation SwitchPortAllocatedTags(lsp_uuid: uuid, tag: Option<integer>)

SwitchPortAllocatedTags(lsp_uuid, tag) :-
    &SwitchPort(.lsp = lsp, .needs_dynamic_tag = true, .parent_name = Some{parent_name}),
    set_is_empty(lsp.tag),
    var lsps_need_tag = Aggregate((parent_name), group2vec(lsp._uuid)),
    SwitchPortReservedTags(parent_name, reserved),
    var dyn_tags = allocate_opt(reserved,
                                lsps_need_tag,
                                1: integer, /* Tag 0 is invalid for nested containers. */
                                4095: integer),
    var lsp_tag = FlatMap(dyn_tags),
    (var lsp_uuid, var tag) = lsp_tag.

/* New tag-to-port assignment:
 * Case 1. Statically reserved tag (via `tag_request`), if any.
 * Case 2. Existing tag for ports that require a dynamically allocated tag and already have one.
 * Case 3. Use newly allocated tags (from `SwitchPortAllocatedTags`) for all other ports.
 */
output relation SwitchPortNewDynamicTag(port: uuid, tag: Option<integer>)

/* Case 1 */
SwitchPortNewDynamicTag(lsp._uuid, tag) :-
    &SwitchPort(.lsp = lsp, .needs_dynamic_tag = false),
    var tag: Option<integer> = match (set_nth(lsp.tag_request, 0)) {
        Some{0} -> None,
        treq    -> treq
    }.

/* Case 2 */
SwitchPortNewDynamicTag(lsp._uuid, Some{tag}) :-
    &SwitchPort(.lsp = lsp, .needs_dynamic_tag = true),
    Some{var tag} = set_nth(lsp.tag, 0).

/* Case 3 */
SwitchPortNewDynamicTag(lsp._uuid, tag) :-
    &SwitchPort(.lsp = lsp, .needs_dynamic_tag = true),
    set_is_empty(lsp.tag),
    SwitchPortAllocatedTags(lsp._uuid, tag).

/* IP_Multicast table (only applicable for Switches). */
sb.Out_IP_Multicast(.datapath = uuid2name(cfg.datapath),
                    .enabled = set_singleton(cfg.enabled),
                    .querier = set_singleton(cfg.querier),
                    .eth_src = cfg.eth_src,
                    .ip4_src = cfg.ip4_src,
                    .ip6_src = cfg.ip6_src,
                    .table_size = set_singleton(cfg.table_size),
                    .idle_timeout = set_singleton(cfg.idle_timeout),
                    .query_interval = set_singleton(cfg.query_interval),
                    .query_max_resp = set_singleton(cfg.query_max_resp)) :-
    &McastSwitchCfg[cfg].
